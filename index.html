<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="M&T Drinks" />
  <title>M&T Drinks Tracker</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap" rel="stylesheet" />

  <!-- Chart.js CDN (required) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23fdfbf7' rx='22'/%3E%3Crect x='15' y='35' width='25' height='35' rx='4' fill='%236ab7ff' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M40 40 C 50 40, 50 60, 40 60' fill='none' stroke='%23544a4a' stroke-width='3'/%3E%3Crect x='15' y='35' width='25' height='10' rx='2' fill='white' opacity='0.5'/%3E%3Cpath d='M60 35 Q 60 60 75 60 Q 90 60 90 35 Z' fill='%23ff8da1' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='75' y1='60' x2='75' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='65' y1='80' x2='85' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M50 20 L52 25 L57 27 L52 29 L50 34 L48 29 L43 27 L48 25 Z' fill='%23ffd700'/%3E%3C/svg%3E" />
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23fdfbf7' rx='22'/%3E%3Crect x='15' y='35' width='25' height='35' rx='4' fill='%236ab7ff' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M40 40 C 50 40, 50 60, 40 60' fill='none' stroke='%23544a4a' stroke-width='3'/%3E%3Crect x='15' y='35' width='25' height='10' rx='2' fill='white' opacity='0.5'/%3E%3Cpath d='M60 35 Q 60 60 75 60 Q 90 60 90 35 Z' fill='%23ff8da1' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='75' y1='60' x2='75' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='65' y1='80' x2='85' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M50 20 L52 25 L57 27 L52 29 L50 34 L48 29 L43 27 L48 25 Z' fill='%23ffd700'/%3E%3C/svg%3E" />

  <style>
    :root { --bg: #fdfbf7; --card: #ffffff; --moe: #6ab7ff; --trish: #ff8da1; --text: #544a4a; --shadow: 0 8px 20px rgba(149, 157, 165, 0.15); }
    body {
      font-family: 'M PLUS Rounded 1c', sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
      overflow: hidden;
      background-image: radial-gradient(#ff8da1 1px, transparent 1px), radial-gradient(#6ab7ff 1px, transparent 1px);
      background-size: 40px 40px;
      background-position: 0 0, 20px 20px;
    }

    header {
      padding: 20px;
      text-align: center;
      font-weight: 800;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
      border-bottom: 2px solid #eee;
      color: var(--trish);
      font-size: 1.2rem;
      z-index: 10;
    }

    #app-content {
      flex: 1;
      padding: 25px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      position: relative;
      -webkit-overflow-scrolling: touch;
    }

    .hidden { display: none !important; }

    #view-login {
      display: flex;
      flex-direction: column;
      justify-content: center;
      height: 100%;
      text-align: center;
    }

    .login-card {
      background: white;
      padding: 30px;
      border-radius: 25px;
      box-shadow: var(--shadow);
    }

    input {
      padding: 15px;
      font-size: 1.2rem;
      border-radius: 50px;
      border: 2px solid #eee;
      background: #f9f9f9;
      text-align: center;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 15px;
      outline: none;
      transition: 0.2s;
    }
    input:focus { border-color: var(--trish); background: #fff; }

    .btn-main {
      padding: 15px;
      background: var(--trish);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      box-shadow: 0 4px 10px rgba(255, 141, 161, 0.4);
      transition: transform 0.1s;
    }
    .btn-main:active { transform: scale(0.95); }

    .user-card {
      background: var(--card);
      border-radius: 30px;
      padding: 20px;
      margin-bottom: 25px;
      text-align: center;
      border: 3px solid transparent;
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow: var(--shadow);
      position: relative;
    }

    .avatar { font-size: 3rem; display: block; margin-bottom: 5px; }
    .user-name { font-size: 1.1rem; font-weight: 800; text-transform: uppercase; color: #888; }
    .count {
      font-size: 5rem;
      font-weight: 800;
      line-height: 1;
      margin: 10px 0;
      color: var(--text);
      text-shadow: 2px 2px 0px #eee;
      font-variant-numeric: tabular-nums;
    }
    .moe .user-name { color: var(--moe); }
    .trish .user-name { color: var(--trish); }

    .controls { display: flex; justify-content: center; gap: 25px; margin-top: 15px; }
    .btn-round {
      width: 70px;
      height: 70px;
      border-radius: 25px;
      border: none;
      font-size: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 5px 0 rgba(0,0,0,0.1);
      transition: transform 0.1s;
      background: #f0f0f0;
      color: #888;
      touch-action: manipulation;
    }
    .btn-round:active { transform: translateY(4px); box-shadow: none; }
    .moe .plus { background: var(--moe); color: white; box-shadow: 0 5px 0 #4a90e2; }
    .trish .plus { background: var(--trish); color: white; box-shadow: 0 5px 0 #e06c80; }

    .analytics-container { background: white; border-radius: 25px; padding: 20px; box-shadow: var(--shadow); }
    .chart-footnote { text-align: center; color: #888; font-weight: 700; margin-top: 10px; font-size: 0.9rem; }
    #history-chart-wrap { position: relative; height: 270px; margin-bottom: 20px; }
    .stats-table { width: 100%; border-collapse: collapse; }
    .stats-table th { text-align: left; color: #aaa; padding: 10px; font-size: 0.8rem; text-transform: uppercase; }
    .stats-table td { padding: 15px 10px; border-bottom: 2px dashed #f0f0f0; font-size: 1.2rem; font-weight: 800; }
    .val-moe { color: var(--moe); }
    .val-trish { color: var(--trish); }

    /* Natural language query UI */
    .query-container { background: white; border-radius: 25px; padding: 20px; box-shadow: var(--shadow); margin-top: 18px; }
    .query-row { display: flex; gap: 12px; align-items: stretch; flex-wrap: wrap; }
    #query-input { margin-bottom: 0; text-align: left; padding-left: 18px; padding-right: 18px; flex: 1 1 220px; }
    .btn-query {
      width: auto;
      min-width: 110px;
      padding: 14px 18px;
      font-size: 1.05rem;
      border-radius: 18px;
      box-shadow: 0 4px 10px rgba(255, 141, 161, 0.35);
      flex: 0 0 auto;
    }

    #query-results {
      margin-top: 14px;
      background: #f9f9f9;
      border: 2px dashed #eee;
      border-radius: 18px;
      padding: 14px;
      font-weight: 800;
      line-height: 1.35;
      min-height: 22px;
      text-align: center;
      white-space: normal;
    }
    #query-results.good { border-color: rgba(106, 183, 255, 0.35); }
    #query-results.bad { border-color: rgba(255, 141, 161, 0.45); }
    #query-results small { display: block; margin-top: 8px; font-weight: 700; color: #888; }

    /* Chart container inside query results */
    #query-chart-wrap {
      margin-top: 12px;
      height: 270px;
      max-height: 290px;
      background: rgba(255,255,255,0.55);
      border-radius: 16px;
      padding: 10px;
      box-sizing: border-box;
    }
    #query-chart {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    #main-nav {
      background: white;
      border-top: 2px solid #eee;
      display: flex;
      padding-bottom: env(safe-area-inset-bottom);
      height: 80px;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.02);
      z-index: 10;
    }
    .nav-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ccc;
      font-size: 0.8rem;
      font-weight: 800;
      gap: 5px;
      transition: 0.2s;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .nav-item.active { color: var(--trish); transform: scale(1.1); }
    .nav-icon { font-size: 1.5rem; }

    @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(0.5); } 100% { opacity: 0; transform: translateY(-50px) scale(1.5); } }
    .kanpai-pop {
      position: absolute;
      font-weight: 900;
      color: #ffbf00;
      font-size: 2rem;
      pointer-events: none;
      animation: floatUp 0.8s ease-out forwards;
      z-index: 99;
      text-shadow: 2px 2px 0 #fff;
      width: 100%;
      text-align: center;
      left: 0;
      top: 20px;
    }
  </style>
</head>

<body>
  <header id="app-header">Welcome</header>

  <div id="app-content">
    <div id="view-login">
      <div class="login-card">
        <div style="font-size: 4rem; margin-bottom: 20px;">‚õ©Ô∏è</div>
        <h2 style="margin-bottom:10px; color: var(--trish);">Welcome Back!</h2>
        <input type="password" id="pass-input" placeholder="Password" />
        <button id="btn-login" class="btn-main">Start Tracker</button>
      </div>
    </div>

    <div id="view-tracker" class="hidden">
      <div style="text-align:center; margin-bottom:20px; color:#aaa; font-weight:bold;">Today</div>

      <div class="user-card moe" id="card-moe">
        <div class="avatar">üêª</div>
        <div class="user-name">Moe</div>
        <div class="count" id="c-moe">...</div>
        <div class="controls">
          <button class="btn-round" onclick="addDrink('Moe', -1)">‚àí</button>
          <button class="btn-round plus" onclick="addDrink('Moe', 1)">üç∫</button>
        </div>
      </div>

      <div class="user-card trish" id="card-trish">
        <div class="avatar">üê±</div>
        <div class="user-name">Trish</div>
        <div class="count" id="c-trish">...</div>
        <div class="controls">
          <button class="btn-round" onclick="addDrink('Trish', -1)">‚àí</button>
          <button class="btn-round plus" onclick="addDrink('Trish', 1)">üçπ</button>
        </div>
      </div>
    </div>

    <div id="view-analytics" class="hidden">
      <div class="analytics-container">
        <h3 style="text-align:center; color:var(--text); margin-top:0;">History Log</h3>
        <div id="history-chart-wrap" class="hidden">
          <canvas id="history-chart"></canvas>
          <div class="chart-footnote">Last 21 days</div>
        </div>
        <table class="stats-table">
          <thead>
            <tr><th>Period</th><th>üêª Moe</th><th>üê± Trish</th></tr>
          </thead>
          <tbody>
            <tr><td>Today</td><td class="val-moe" id="stat-day-moe">0</td><td class="val-trish" id="stat-day-trish">0</td></tr>
            <tr><td>7 Days</td><td class="val-moe" id="stat-week-moe">0</td><td class="val-trish" id="stat-week-trish">0</td></tr>
            <tr><td>30 Days</td><td class="val-moe" id="stat-month-moe">0</td><td class="val-trish" id="stat-month-trish">0</td></tr>
            <tr class="hidden"><td>All Time</td><td class="val-moe" id="stat-all-moe">0</td><td class="val-trish" id="stat-all-trish">0</td></tr>
          </tbody>
        </table>
      </div>

      <div class="query-container">
        <h3 style="text-align:center; color:var(--text); margin-top:0;">Ask the Log</h3>
        <div class="query-row">
          <input type="text" id="query-input" placeholder="Ask a question... (ex: Drinks today? Moe 12/1-12/15? Weekends last month?)" />
          <button id="query-submit" class="btn-main btn-query">Ask</button>
        </div>

        <!-- Prepared to hold both text + canvas (required) -->
        <div id="query-results">
          <div id="query-text"></div>
          <div id="query-chart-wrap" class="hidden">
            <canvas id="query-chart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <nav id="main-nav" class="hidden">
    <div class="nav-item active" id="tab-tracker" onclick="switchTab('tracker')">
      <span class="nav-icon">üìù</span><span>Tracker</span>
    </div>
    <div class="nav-item" id="tab-analytics" onclick="switchTab('analytics')">
      <span class="nav-icon">üìä</span><span>History</span>
    </div>
  </nav>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, onValue, push, remove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

    // --- Firebase ---
    const firebaseConfig = {
      apiKey: "AIzaSyDwjSeEdz3g6ofnvvURIr_Q_q0KII4QtdU",
      authDomain: "drinks-tracker-cb5e5.firebaseapp.com",
      databaseURL: "https://drinks-tracker-cb5e5-default-rtdb.firebaseio.com",
      projectId: "drinks-tracker-cb5e5",
      storageBucket: "drinks-tracker-cb5e5.firebasestorage.app",
      messagingSenderId: "670928393598",
      appId: "1:670928393598:web:1d3bf4c73fe8f7714d0f2f",
      measurementId: "G-36G1HBRE9K"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const historyRef = ref(db, "history");

    // --- DOM ---
    const el = {
      header: document.getElementById("app-header"),
      viewLogin: document.getElementById("view-login"),
      viewTracker: document.getElementById("view-tracker"),
      viewAnalytics: document.getElementById("view-analytics"),
      nav: document.getElementById("main-nav"),
      tabTracker: document.getElementById("tab-tracker"),
      tabAnalytics: document.getElementById("tab-analytics"),
      pass: document.getElementById("pass-input"),
      btnLogin: document.getElementById("btn-login"),

      cMoe: document.getElementById("c-moe"),
      cTrish: document.getElementById("c-trish"),
      cardMoe: document.getElementById("card-moe"),
      cardTrish: document.getElementById("card-trish"),

      queryInput: document.getElementById("query-input"),
      querySubmit: document.getElementById("query-submit"),
      queryResults: document.getElementById("query-results"),
      queryText: document.getElementById("query-text"),
      queryChartWrap: document.getElementById("query-chart-wrap"),
      queryChartCanvas: document.getElementById("query-chart"),
      historyChartWrap: document.getElementById("history-chart-wrap"),
      historyChartCanvas: document.getElementById("history-chart")
    };

    let allHistory = {};
    let eventsCache = [];

    const DAY_MS = 24 * 60 * 60 * 1000;

    // PH0-4: NY timezone hygiene foundation
    const TZ = "America/New_York";

    const DOW_FULL = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const DOW_SHORT = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const DOW_ALIASES = {
      sun: 0, sunday: 0,
      mon: 1, monday: 1,
      tue: 2, tues: 2, tuesday: 2,
      wed: 3, weds: 3, wednesday: 3,
      thu: 4, thur: 4, thurs: 4, thursday: 4,
      fri: 5, friday: 5,
      sat: 6, saturday: 6
    };

    const monthMap = {
      january: 0, jan: 0,
      february: 1, feb: 1,
      march: 2, mar: 2,
      april: 3, apr: 3,
      may: 4,
      june: 5, jun: 5,
      july: 6, jul: 6,
      august: 7, aug: 7,
      september: 8, sep: 8, sept: 8,
      october: 9, oct: 9,
      november: 10, nov: 10,
      december: 11, dec: 11
    };

    const numberWords = {
      a: 1, an: 1, one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10,
      eleven: 11, twelve: 12, thirteen: 13, fourteen: 14, fifteen: 15, sixteen: 16, seventeen: 17, eighteen: 18, nineteen: 19, twenty: 20
    };

    function pad2(n) {
      const x = String(n);
      return x.length === 1 ? "0" + x : x;
    }

    function parseDayKey(dayKey) {
      const m = String(dayKey || "").match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return null;
      return { year: parseInt(m[1], 10), month: parseInt(m[2], 10), day: parseInt(m[3], 10) };
    }

    function getTzYmdParts(ts, timeZone = TZ) {
      const fmt = new Intl.DateTimeFormat("en-US", { timeZone, year: "numeric", month: "2-digit", day: "2-digit" });
      const parts = fmt.formatToParts(new Date(ts));
      const y = parts.find(p => p.type === "year")?.value;
      const m = parts.find(p => p.type === "month")?.value;
      const d = parts.find(p => p.type === "day")?.value;
      if (!y || !m || !d) return null;
      return { year: parseInt(y, 10), month: parseInt(m, 10), day: parseInt(d, 10) };
    }

    // dayKeyFromTs(ts) -> YYYY-MM-DD in NY
    function dayKeyFromTs(ts) {
      const p = getTzYmdParts(ts, TZ);
      if (!p) return null;
      return `${p.year}-${pad2(p.month)}-${pad2(p.day)}`;
    }

    // dayKeyAddDays(dayKey, n) -> YYYY-MM-DD (calendar math, DST safe)
    function dayKeyAddDays(dayKey, n) {
      const p = parseDayKey(dayKey);
      if (!p || !Number.isFinite(n)) return null;
      const base = Date.UTC(p.year, p.month - 1, p.day);
      const dt = new Date(base + n * DAY_MS);
      const y = dt.getUTCFullYear();
      const m = dt.getUTCMonth() + 1;
      const d = dt.getUTCDate();
      return `${y}-${pad2(m)}-${pad2(d)}`;
    }

    function dowFromDayKey(dayKey) {
      const p = parseDayKey(dayKey);
      if (!p) return null;
      return new Date(Date.UTC(p.year, p.month - 1, p.day)).getUTCDay();
    }

    // weekKeyFromDayKey(dayKey) -> Monday dayKey
    function weekKeyFromDayKey(dayKey) {
      const dow = dowFromDayKey(dayKey);
      if (dow === null) return null;
      const diff = (dow + 6) % 7; // Monday=0 ... Sunday=6
      return dayKeyAddDays(dayKey, -diff);
    }

    function currentDayKey() {
      return dayKeyFromTs(Date.now());
    }

    function currentWeekKey() {
      const dk = currentDayKey();
      return dk ? weekKeyFromDayKey(dk) : null;
    }

    function monthKeyFromDayKey(dayKey) {
      const p = parseDayKey(dayKey);
      if (!p) return null;
      return `${p.year}-${pad2(p.month)}-01`;
    }

    function addMonthsToMonthKey(monthKey, n) {
      const p = parseDayKey(monthKey);
      if (!p || !Number.isFinite(n)) return null;
      const dt = new Date(Date.UTC(p.year, (p.month - 1) + n, 1));
      const y = dt.getUTCFullYear();
      const m = dt.getUTCMonth() + 1;
      return `${y}-${pad2(m)}-01`;
    }

    function dayKeyDiffDays(startDayKey, endDayKeyExclusive) {
      const a = parseDayKey(startDayKey);
      const b = parseDayKey(endDayKeyExclusive);
      if (!a || !b) return 1;
      const ams = Date.UTC(a.year, a.month - 1, a.day);
      const bms = Date.UTC(b.year, b.month - 1, b.day);
      return Math.max(1, Math.round((bms - ams) / DAY_MS));
    }

    function monthNameFromIndex(idx) {
      const names = ["January","February","March","April","May","June","July","August","September","October","November","December"];
      return names[idx] || "";
    }

    function fmtDayKey(dayKey) {
      const p = parseDayKey(dayKey);
      if (!p) return "";
      const m = monthNameFromIndex(p.month - 1).slice(0, 3);
      return `${m} ${p.day}, ${p.year}`;
    }

    function fmtRangeDayKeys(startDayKey, endDayKeyExclusive) {
      const endDayKey = dayKeyAddDays(endDayKeyExclusive, -1);
      const a = fmtDayKey(startDayKey);
      const b = fmtDayKey(endDayKey);
      return a === b ? a : `${a} - ${b}`;
    }

    function plural(n, word) {
      return Math.abs(n) === 1 ? word : word + "s";
    }

    function cssVar(name, fallback = "") {
      try {
        const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return v || fallback;
      } catch {
        return fallback;
      }
    }

    function setQueryResult(html, ok) {
      if (!el.queryResults || !el.queryText) return;
      el.queryResults.classList.remove("good", "bad");
      el.queryResults.classList.add(ok ? "good" : "bad");
      el.queryText.innerHTML = html;
    }

    function normalizeQuery(q) {
      return String(q || "")
        .toLowerCase()
        .replace(/[‚Äô]/g, "'")
        .replace(/\s+/g, " ")
        .trim();
    }

    function parseNumber(qLower) {
      const m = qLower.match(/\b(\d{1,3}|a|an|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\b/);
      if (!m) return null;
      const t = m[1];
      if (/^\d+$/.test(t)) return parseInt(t, 10);
      return numberWords[t] ?? null;
    }

    // PH0-4: eventsCache stores dayKey + weekKey (not browser-local dayStart/dow)
    function rebuildEventsCache() {
      const out = [];
      for (const entry of Object.values(allHistory || {})) {
        if (!entry) continue;
        const u = entry.user;
        const ts = entry.timestamp;
        if (typeof u !== "string" || typeof ts !== "number") continue;

        const v = (typeof entry.value === "number" && Number.isFinite(entry.value)) ? entry.value : 1;
        const dayKey = dayKeyFromTs(ts);
        if (!dayKey) continue;
        const weekKey = weekKeyFromDayKey(dayKey);
        if (!weekKey) continue;

        out.push({ user: u, ts, v, dayKey, weekKey });
      }
      out.sort((a, b) => a.ts - b.ts);
      eventsCache = out;
    }

    function parseIntent(qLower) {
      const wantsDaysCount = /\bhow many days\b|\bnumber of days\b|\bdays did\b/.test(qLower);
      const wantsAvg = /\baverage\b|\bavg\b|\bper day\b|\bdaily average\b/.test(qLower);
      const wantsDiff = /\bdifference\b|\bdiff\b|\bdelta\b|\bby how many\b|\bmargin\b/.test(qLower);
      const wantsBreakdownByDow = /\bday of week\b|\bby day of week\b|\bweekday breakdown\b/.test(qLower);
      const wantsBreakdownByDate = /\bday by day\b|\beach day\b|\bdaily breakdown\b|\bper day\b(?!.*average)/.test(qLower);
      const wantsPeakDay = /\bpeak\b|\bhighest\b|\bmax\b|\bmost in a day\b|\bbiggest day\b|\bwhat day\b.*\bmost\b/.test(qLower);

      const compareSignals =
        /\bvs\b|\bversus\b|\bcompare\b|\bwho (won|wins|had more|drank more)\b|\bmore than\b|\bless than\b|\bbeat\b|\bwinner\b/.test(qLower) ||
        (/\bwho\b/.test(qLower) && /\bmore\b|\bmost\b/.test(qLower));

      const whoSignals = /^\s*who\b/.test(qLower) || /\bwho drank\b|\bwho had\b/.test(qLower);

      let type = "count";
      if (wantsPeakDay) type = "peak_day";
      else if (wantsDaysCount) type = "days_count";
      else if (wantsAvg) type = "average";
      else if (wantsDiff) type = "difference";
      else if (compareSignals) type = "comparison";
      else if (wantsBreakdownByDow || wantsBreakdownByDate) type = "breakdown";

      const breakdownMode = wantsBreakdownByDow ? "dow" : (wantsBreakdownByDate ? "date" : null);

      return { type, breakdownMode, whoSignals };
    }

    function parseUsers(qLower, intent) {
      const hasMoe = /\bmoe\b/.test(qLower) || /\bme\b/.test(qLower) || /\bmy\b/.test(qLower);
      const hasTrish = /\btrish\b/.test(qLower);

      const bothSignals = /\b(both|all|together|us|we|everyone)\b/.test(qLower) || (hasMoe && hasTrish);

      if (bothSignals) return { users: ["Moe", "Trish"], mode: "both" };
      if (hasMoe) return { users: ["Moe"], mode: "single" };
      if (hasTrish) return { users: ["Trish"], mode: "single" };

      if (intent.whoSignals) return { users: ["Moe", "Trish"], mode: "who" };
      return { users: ["Moe", "Trish"], mode: "both" };
    }

    function expandDowRange(d1, d2) {
      const order = [1,2,3,4,5,6,0];
      const i1 = order.indexOf(d1);
      const i2 = order.indexOf(d2);
      if (i1 === -1 || i2 === -1) return null;

      const out = [];
      if (i2 >= i1) {
        for (let i = i1; i <= i2; i++) out.push(order[i]);
      } else {
        for (let i = i1; i < order.length; i++) out.push(order[i]);
        for (let i = 0; i <= i2; i++) out.push(order[i]);
      }
      return out;
    }

    function parseDayFilter(qLower) {
      if (/\bweekends?\b/.test(qLower) || /\bweek end(s)?\b/.test(qLower)) {
        return { days: [6, 0], label: "weekends" };
      }
      if (/\bweekdays?\b/.test(qLower)) {
        return { days: [1,2,3,4,5], label: "weekdays" };
      }

      const rangeMatch = qLower.match(/\b(mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)\b\s*(?:-|to|thru|through)\s*\b(mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)\b/);
      if (rangeMatch) {
        const a = rangeMatch[1].replace(/sday|nesday|rsday|urday/g, "");
        const b = rangeMatch[2].replace(/sday|nesday|rsday|urday/g, "");
        const d1 = DOW_ALIASES[a] ?? null;
        const d2 = DOW_ALIASES[b] ?? null;
        const days = (d1 !== null && d2 !== null) ? expandDowRange(d1, d2) : null;
        if (days && days.length) return { days, label: `${DOW_SHORT[d1]}-${DOW_SHORT[d2]}` };
      }

      const pluralMatch = qLower.match(/\b(sundays|mondays|tuesdays|wednesdays|thursdays|fridays|saturdays)\b/);
      if (pluralMatch) {
        const token = pluralMatch[1].slice(0, -1);
        const dow = DOW_ALIASES[token] ?? null;
        if (dow !== null) return { days: [dow], label: pluralMatch[1] };
      }

      return null;
    }

    function inferYearForMonthDay(monthIdx, day, nowDayKey, qLower, opts = {}) {
      const nowParts = parseDayKey(nowDayKey);
      if (!nowParts) return new Date().getFullYear();

      const nowY = nowParts.year;
      const hasNext = !!opts.hasNext;
      const hasThis = !!opts.hasThis;

      const candidate = `${nowY}-${pad2(monthIdx + 1)}-${pad2(day)}`;

      if (hasNext) {
        if (candidate <= nowDayKey) return nowY + 1;
        return nowY;
      }

      if (hasThis) return nowY;

      if (candidate > nowDayKey) return nowY - 1;
      return nowY;
    }

    function parseDateStringToDayKey(dateStr, nowDayKey, qLower) {
      const s = String(dateStr || "").trim().toLowerCase();
      const hasNext = /\bnext\b/.test(qLower);
      const hasThis = /\bthis\b/.test(qLower) || /\bcurrent\b/.test(qLower);

      let m = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (m) {
        const y = parseInt(m[1], 10);
        const mo = parseInt(m[2], 10);
        const d = parseInt(m[3], 10);
        if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return null;
        return `${y}-${pad2(mo)}-${pad2(d)}`;
      }

      m = s.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?$/);
      if (m) {
        const mo = parseInt(m[1], 10);
        const d = parseInt(m[2], 10);
        let y;
        if (m[3]) {
          y = parseInt(m[3], 10);
          if (y < 100) y = 2000 + y;
        } else {
          y = inferYearForMonthDay(mo - 1, d, nowDayKey, qLower, { hasNext, hasThis });
        }
        return `${y}-${pad2(mo)}-${pad2(d)}`;
      }

      m = s.match(/^(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:\s*,?\s*(\d{4}))?$/);
      if (m) {
        const monthToken = m[1];
        const moIdx = monthMap[monthToken] ?? null;
        if (moIdx === null) return null;
        const d = parseInt(m[2], 10);
        const y = m[3] ? parseInt(m[3], 10) : inferYearForMonthDay(moIdx, d, nowDayKey, qLower, { hasNext, hasThis });
        return `${y}-${pad2(moIdx + 1)}-${pad2(d)}`;
      }

      m = s.match(/^(\d{1,2})\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\s*,?\s*(\d{4}))?$/);
      if (m) {
        const d = parseInt(m[1], 10);
        const monthToken = m[2];
        const moIdx = monthMap[monthToken] ?? null;
        if (moIdx === null) return null;
        const y = m[3] ? parseInt(m[3], 10) : inferYearForMonthDay(moIdx, d, nowDayKey, qLower, { hasNext, hasThis });
        return `${y}-${pad2(moIdx + 1)}-${pad2(d)}`;
      }

      return null;
    }

    function extractDateTokens(qLower, nowDayKey) {
      const tokens = [];

      function addToken(text, idx) {
        const dayKey = parseDateStringToDayKey(text, nowDayKey, qLower);
        if (!dayKey) return;
        tokens.push({ text, idx, len: text.length, dayKey });
      }

      for (const match of qLower.matchAll(/\b(19\d{2}|20\d{2})-(\d{1,2})-(\d{1,2})\b/g)) addToken(match[0], match.index ?? 0);
      for (const match of qLower.matchAll(/\b(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?\b/g)) addToken(match[0], match.index ?? 0);
      for (const match of qLower.matchAll(/\b(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:\s*,?\s*(\d{4}))?\b/g)) addToken(match[0], match.index ?? 0);
      for (const match of qLower.matchAll(/\b(\d{1,2})\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\s*,?\s*(\d{4}))?\b/g)) addToken(match[0], match.index ?? 0);

      const seen = new Set();
      const deduped = [];
      for (const t of tokens.sort((a, b) => a.idx - b.idx)) {
        const k = `${t.idx}:${t.len}:${t.dayKey}`;
        if (seen.has(k)) continue;
        seen.add(k);
        deduped.push(t);
      }
      return deduped;
    }

    function parseMonthRange(qLower, nowDayKey) {
      let monthIdx = null;

      for (const [token, idx] of Object.entries(monthMap)) {
        const re = new RegExp("\\b" + token + "\\b", "i");

        if (token === "may") {
          const ok = /\bin may\b/.test(qLower) || /\bmay\s+\d{4}\b/.test(qLower) || /\bmay\s+\d{1,2}\b/.test(qLower);
          if (!ok) continue;
        }

        if (re.test(qLower)) { monthIdx = idx; break; }
      }

      if (monthIdx === null) return null;

      const yearMatch = qLower.match(/\b(19\d{2}|20\d{2})\b/);
      const nowParts = parseDayKey(nowDayKey);
      if (!nowParts) return null;

      const nowY = nowParts.year;
      const nowM = nowParts.month - 1;
      const hasNext = /\bnext\b/.test(qLower);
      const hasLast = /\blast\b|\bprevious\b/.test(qLower);
      const hasThis = /\bthis\b|\bcurrent\b/.test(qLower);

      let year;
      if (yearMatch) {
        year = parseInt(yearMatch[1], 10);
      } else if (hasNext) {
        year = (monthIdx <= nowM) ? nowY + 1 : nowY;
      } else if (hasLast) {
        year = (monthIdx >= nowM) ? nowY - 1 : nowY;
      } else if (hasThis) {
        year = nowY;
      } else {
        year = (monthIdx > nowM) ? nowY - 1 : nowY;
      }

      const startDayKey = `${year}-${pad2(monthIdx + 1)}-01`;
      const nextMonthStart = new Date(Date.UTC(year, monthIdx + 1, 1));
      const endDayKeyExclusive = `${nextMonthStart.getUTCFullYear()}-${pad2(nextMonthStart.getUTCMonth() + 1)}-01`;

      return { startDayKey, endDayKeyExclusive, label: `${monthNameFromIndex(monthIdx)} ${year}` };
    }

    // PH0-4: parseNamedRange uses NY dayKey + Monday weekKey (no browser local boundaries)
    function parseNamedRange(qLower, nowDayKey, ctx) {
      const todayDayKey = nowDayKey;
      const tomorrowDayKey = dayKeyAddDays(todayDayKey, 1);

      if (/\btoday\b/.test(qLower)) {
        return { startDayKey: todayDayKey, endDayKeyExclusive: tomorrowDayKey, label: "today" };
      }
      if (/\byesterday\b/.test(qLower)) {
        const y = dayKeyAddDays(todayDayKey, -1);
        return { startDayKey: y, endDayKeyExclusive: todayDayKey, label: "yesterday" };
      }

      if (/\bthis week\b/.test(qLower)) {
        const wk = currentWeekKey();
        return { startDayKey: wk, endDayKeyExclusive: tomorrowDayKey, label: "this week" };
      }

      if (/\b(calendar last week|previous week|last calendar week)\b/.test(qLower)) {
        const startThis = currentWeekKey();
        const startLast = dayKeyAddDays(startThis, -7);
        return { startDayKey: startLast, endDayKeyExclusive: startThis, label: "last week (Mon-Sun)" };
      }

      if (/\blast week\b/.test(qLower)) {
        // Default to calendar last week (Mon-Sun) to match product week boundaries.
        const startThis = currentWeekKey();
        const startLast = dayKeyAddDays(startThis, -7);
        return { startDayKey: startLast, endDayKeyExclusive: startThis, label: "last week (Mon-Sun)" };
      }

      if (/\bthis month\b/.test(qLower)) {
        const p = parseDayKey(todayDayKey);
        const startDayKey = `${p.year}-${pad2(p.month)}-01`;
        const endDayKeyExclusive = addMonthsToMonthKey(startDayKey, 1);
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey < endDayKeyExclusive ? tomorrowDayKey : endDayKeyExclusive, label: "this month" };
      }
      if (/\blast month\b/.test(qLower)) {
        const p = parseDayKey(todayDayKey);
        const startThis = `${p.year}-${pad2(p.month)}-01`;
        const startPrev = addMonthsToMonthKey(startThis, -1);
        return { startDayKey: startPrev, endDayKeyExclusive: startThis, label: "last month" };
      }

      if (/\bthis year\b/.test(qLower) || /\bcurrent year\b/.test(qLower) || /\bytd\b/.test(qLower)) {
        const p = parseDayKey(todayDayKey);
        const startDayKey = `${p.year}-01-01`;
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey, label: "this year" };
      }
      if (/\blast year\b|\bprevious year\b/.test(qLower)) {
        const p = parseDayKey(todayDayKey);
        const startThis = `${p.year}-01-01`;
        const startPrev = `${p.year - 1}-01-01`;
        return { startDayKey: startPrev, endDayKeyExclusive: startThis, label: "last year" };
      }

      if (/\blast weekend\b/.test(qLower)) {
        // Weekend = Sat-Sun. Use current week (Mon start) and take the prior week's Sat-Sun.
        const wk = currentWeekKey();
        const satThisWeek = dayKeyAddDays(wk, 5);
        const satLastWeek = dayKeyAddDays(satThisWeek, -7);
        const endExclusive = dayKeyAddDays(satLastWeek, 2);
        return { startDayKey: satLastWeek, endDayKeyExclusive: endExclusive, label: "last weekend" };
      }
      if (/\bthis weekend\b/.test(qLower)) {
        const wk = currentWeekKey();
        const satThisWeek = dayKeyAddDays(wk, 5);
        const endExclusive = dayKeyAddDays(satThisWeek, 2);
        const capEnd = (tomorrowDayKey < endExclusive) ? tomorrowDayKey : endExclusive;
        return { startDayKey: satThisWeek, endDayKeyExclusive: capEnd, label: "this weekend" };
      }

      const wd = qLower.match(/\b(last|this|next)\s+(sun(?:day)?|mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?)\b/);
      if (wd) {
        const mod = wd[1];
        const raw = wd[2].replace(/sday|nesday|rsday|urday/g, "");
        const target = DOW_ALIASES[raw];
        if (target === undefined || target === null) return null;

        const todayDow = dowFromDayKey(todayDayKey);

        if (mod === "last") {
          let diff = (todayDow - target + 7) % 7;
          if (diff === 0) diff = 7;
          const dk = dayKeyAddDays(todayDayKey, -diff);
          return { startDayKey: dk, endDayKeyExclusive: dayKeyAddDays(dk, 1), label: `last ${DOW_FULL[target]}` };
        }

        const wk = currentWeekKey();
        const offset = (target + 6) % 7; // Monday=0 ... Sunday=6
        const thisDk = dayKeyAddDays(wk, offset);

        if (mod === "this") {
          return { startDayKey: thisDk, endDayKeyExclusive: dayKeyAddDays(thisDk, 1), label: `this ${DOW_FULL[target]}` };
        }

        const nextDk = dayKeyAddDays(thisDk, 7);
        return { startDayKey: nextDk, endDayKeyExclusive: dayKeyAddDays(nextDk, 1), label: `next ${DOW_FULL[target]}` };
      }

      const onWd = qLower.match(/\bon\s+(sun(?:day)?|mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?)\b/);
      if (onWd) {
        const raw = onWd[1].replace(/sday|nesday|rsday|urday/g, "");
        const target = DOW_ALIASES[raw];
        const todayDow = dowFromDayKey(todayDayKey);
        const diff = (todayDow - target + 7) % 7;
        const dk = dayKeyAddDays(todayDayKey, -diff);
        return { startDayKey: dk, endDayKeyExclusive: dayKeyAddDays(dk, 1), label: `on ${DOW_FULL[target]}` };
      }

      return null;
    }

    function parseNumericRelative(qLower, nowDayKey) {
      const todayDayKey = nowDayKey;
      const tomorrowDayKey = dayKeyAddDays(todayDayKey, 1);

      const days = qLower.match(/\b(past|last)\s+(\d{1,3}|a|an|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\s+days?\b/);
      if (days) {
        const n = /^\d+$/.test(days[2]) ? parseInt(days[2], 10) : (numberWords[days[2]] ?? 1);
        const nn = Math.max(1, n);
        const startDayKey = dayKeyAddDays(todayDayKey, -(nn - 1));
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey, label: `past ${nn} ${plural(nn, "day")}` };
      }

      const weeks = qLower.match(/\b(past|last)\s+(\d{1,2}|a|an|one|two|three|four|five|six|seven|eight)\s+weeks?\b/);
      if (weeks) {
        const n = /^\d+$/.test(weeks[2]) ? parseInt(weeks[2], 10) : (numberWords[weeks[2]] ?? 1);
        const nn = Math.max(1, n);
        const daysCount = nn * 7;
        const startDayKey = dayKeyAddDays(todayDayKey, -(daysCount - 1));
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey, label: `past ${nn} ${plural(nn, "week")}` };
      }

      const months = qLower.match(/\b(past|last)\s+(\d{1,2}|a|an|one|two|three|four|five|six)\s+months?\b/);
      if (months) {
        const n = /^\d+$/.test(months[2]) ? parseInt(months[2], 10) : (numberWords[months[2]] ?? 1);
        const nn = Math.max(1, n);
        const daysCount = nn * 30;
        const startDayKey = dayKeyAddDays(todayDayKey, -(daysCount - 1));
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey, label: `past ${nn} ${plural(nn, "month")}` };
      }

      const nDays = qLower.match(/\blast\s+(7|30)\s+days?\b/);
      if (nDays) {
        const nn = parseInt(nDays[1], 10);
        const startDayKey = dayKeyAddDays(todayDayKey, -(nn - 1));
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey, label: `past ${nn} days` };
      }

      return null;
    }

    function resolveTimeRange(rawQ, nowDayKey, ctx) {
      const qLower = normalizeQuery(rawQ);
      const todayDayKey = nowDayKey;
      const tomorrowDayKey = dayKeyAddDays(todayDayKey, 1);

      const dayFilter = parseDayFilter(qLower);
      const dateTokens = extractDateTokens(qLower, nowDayKey);

      if (/\bsince\b/.test(qLower) && dateTokens.length >= 1) {
        const sinceIdx = qLower.indexOf("since");
        const t = dateTokens.find(x => x.idx >= sinceIdx) || dateTokens[0];
        return { startDayKey: t.dayKey, endDayKeyExclusive: tomorrowDayKey, label: `since ${fmtDayKey(t.dayKey)}` };
      }

      if (/\bon\b/.test(qLower) && dateTokens.length >= 1) {
        const onIdx = qLower.indexOf("on");
        const t = dateTokens.find(x => x.idx >= onIdx) || dateTokens[0];
        return { startDayKey: t.dayKey, endDayKeyExclusive: dayKeyAddDays(t.dayKey, 1), label: `on ${fmtDayKey(t.dayKey)}` };
      }

      if (/\bbetween\b/.test(qLower) && dateTokens.length >= 2) {
        const betweenIdx = qLower.indexOf("between");
        const andIdx = qLower.indexOf(" and ", betweenIdx);
        const t1 = dateTokens.find(x => x.idx >= betweenIdx) || dateTokens[0];
        const t2 = (andIdx >= 0 ? dateTokens.find(x => x.idx >= andIdx) : null) || dateTokens[1];
        const start = (t1.dayKey <= t2.dayKey) ? t1.dayKey : t2.dayKey;
        const endInclusive = (t1.dayKey <= t2.dayKey) ? t2.dayKey : t1.dayKey;
        return { startDayKey: start, endDayKeyExclusive: dayKeyAddDays(endInclusive, 1), label: `between ${fmtDayKey(start)} and ${fmtDayKey(endInclusive)}` };
      }

      if (/\bfrom\b/.test(qLower) && dateTokens.length >= 2) {
        const fromIdx = qLower.indexOf("from");
        const toIdx = qLower.indexOf(" to ", fromIdx);
        const t1 = dateTokens.find(x => x.idx >= fromIdx) || dateTokens[0];
        const t2 = (toIdx >= 0 ? dateTokens.find(x => x.idx >= toIdx) : null) || dateTokens[1];
        const start = (t1.dayKey <= t2.dayKey) ? t1.dayKey : t2.dayKey;
        const endInclusive = (t1.dayKey <= t2.dayKey) ? t2.dayKey : t1.dayKey;
        return { startDayKey: start, endDayKeyExclusive: dayKeyAddDays(endInclusive, 1), label: `${fmtDayKey(start)} to ${fmtDayKey(endInclusive)}` };
      }

      if (dateTokens.length >= 2) {
        for (let i = 0; i < dateTokens.length - 1; i++) {
          const a = dateTokens[i];
          const b = dateTokens[i + 1];
          const mid = qLower.slice(a.idx + a.len, b.idx).trim();

          const isDashRange = mid === "-" || mid === "\u2013" || mid === "\u2014";
          const isToRange = mid === "to" || mid === "thru" || mid === "through" || mid === "until";

          if (isDashRange || isToRange || /^-$/.test(mid)) {
            const start = (a.dayKey <= b.dayKey) ? a.dayKey : b.dayKey;
            const endInclusive = (a.dayKey <= b.dayKey) ? b.dayKey : a.dayKey;
            return { startDayKey: start, endDayKeyExclusive: dayKeyAddDays(endInclusive, 1), label: `${fmtDayKey(start)} to ${fmtDayKey(endInclusive)}` };
          }
        }
      }

      const monthRange = parseMonthRange(qLower, nowDayKey);
      if (monthRange) return monthRange;

      const named = parseNamedRange(qLower, nowDayKey, ctx);
      if (named) return named;

      const rel = parseNumericRelative(qLower, nowDayKey);
      if (rel) return rel;

      if (/\bweek\b/.test(qLower)) {
        return { startDayKey: dayKeyAddDays(todayDayKey, -6), endDayKeyExclusive: tomorrowDayKey, label: "past 7 days" };
      }
      if (/\bmonth\b/.test(qLower)) {
        return { startDayKey: dayKeyAddDays(todayDayKey, -29), endDayKeyExclusive: tomorrowDayKey, label: "past 30 days" };
      }

      if (dayFilter && /\b(this year|last year|this month|last month|this week|last week|past|last|since|between|from|\d{1,2}\/\d{1,2}|20\d{2}-\d{1,2}-\d{1,2})\b/.test(qLower) === false) {
        const p = parseDayKey(todayDayKey);
        const startDayKey = `${p.year}-01-01`;
        return { startDayKey, endDayKeyExclusive: tomorrowDayKey, label: "this year" };
      }

      return null;
    }

    // PH0-4: aggregate uses dayKey range and derives dow/weekKey from dayKey
    function aggregate(users, range, filters) {
      const startDayKey = range.startDayKey;
      const endDayKeyExclusive = range.endDayKeyExclusive;
      const dayFilter = filters?.dayFilter;

      const sums = {};
      const daySets = {};
      for (const u of users) {
        sums[u] = 0;
        daySets[u] = new Set();
      }

      let total = 0;
      const perDay = new Map(); // key: dayKey
      const perDow = new Map(); // key: 0-6

      const allowedDays = dayFilter?.days ? new Set(dayFilter.days) : null;

      for (const e of eventsCache) {
        if (!e) continue;
        if (!sums.hasOwnProperty(e.user)) continue;

        const dk = e.dayKey;
        if (dk < startDayKey || dk >= endDayKeyExclusive) continue;

        const dow = dowFromDayKey(dk);
        if (allowedDays && !allowedDays.has(dow)) continue;

        sums[e.user] += e.v;
        total += e.v;

        daySets[e.user].add(dk);

        if (!perDay.has(dk)) perDay.set(dk, { Moe: 0, Trish: 0, total: 0 });
        const pd = perDay.get(dk);
        pd[e.user] = (pd[e.user] || 0) + e.v;
        pd.total += e.v;

        if (!perDow.has(dow)) perDow.set(dow, { Moe: 0, Trish: 0, total: 0 });
        const pw = perDow.get(dow);
        pw[e.user] = (pw[e.user] || 0) + e.v;
        pw.total += e.v;
      }

      return { sums, total, perDay, perDow, daySets };
    }

    function daysTouchedByRange(range) {
      return dayKeyDiffDays(range.startDayKey, range.endDayKeyExclusive);
    }

    let queryChart = null;
    let historyChart = null;

    function destroyQueryChart() {
      if (queryChart) {
        queryChart.destroy();
        queryChart = null;
      }
      if (el.queryChartWrap) el.queryChartWrap.classList.add("hidden");
    }

    function destroyHistoryChart() {
      if (historyChart) {
        historyChart.destroy();
        historyChart = null;
      }
      if (el.historyChartWrap) el.historyChartWrap.classList.add("hidden");
    }

    function calcRangeSpanDays(range) {
      return dayKeyDiffDays(range.startDayKey, range.endDayKeyExclusive);
    }

    function labelForDay(dayKey) {
      const p = parseDayKey(dayKey);
      if (!p) return "";
      return `${monthNameFromIndex(p.month - 1).slice(0,3)} ${p.day}`;
    }

    function labelForWeek(weekStartDayKey) {
      const p = parseDayKey(weekStartDayKey);
      if (!p) return "Week";
      return `Week of ${monthNameFromIndex(p.month - 1).slice(0,3)} ${p.day}`;
    }

    function labelForMonth(monthStartDayKey) {
      const p = parseDayKey(monthStartDayKey);
      if (!p) return "Month";
      return `${monthNameFromIndex(p.month - 1).slice(0,3)} ${p.year}`;
    }

    function renderChart(intent, userInfo, agg, range) {
      destroyQueryChart();

      if (!window.Chart || !el.queryChartCanvas || !el.queryChartWrap) return;

      const moeTotal = agg?.sums?.Moe || 0;
      const trishTotal = agg?.sums?.Trish || 0;
      const hasAny = (moeTotal + trishTotal) > 0;
      if (!hasAny) return;

      const moeColor = cssVar("--moe", "#6ab7ff");
      const trishColor = cssVar("--trish", "#ff8da1");
      const textColor = cssVar("--text", "#544a4a");

      const spanDays = calcRangeSpanDays(range);
      const isSingleDay = spanDays === 1;

      const wantsPie = intent?.type === "comparison" || (intent?.whoSignals && isSingleDay);

      const commonPlugins = {
        legend: {
          display: true,
          position: "bottom",
          labels: {
            color: textColor,
            boxWidth: 14,
            boxHeight: 14,
            padding: 14,
            font: { weight: "800" }
          }
        },
        tooltip: {
          enabled: true,
          titleColor: "#fff",
          bodyColor: "#fff",
          footerColor: "#fff",
          callbacks: {
            labelTextColor: () => "#fff"
          }
        }
      };

      if (wantsPie) {
        el.queryChartWrap.classList.remove("hidden");

        queryChart = new window.Chart(el.queryChartCanvas, {
          type: "pie",
          data: {
            labels: ["Moe", "Trish"],
            datasets: [{
              data: [moeTotal, trishTotal],
              backgroundColor: [moeColor, trishColor],
              borderColor: ["#ffffff", "#ffffff"],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: commonPlugins,
            animation: { duration: 450 }
          }
        });
        return;
      }

      if (intent?.type === "breakdown" && intent?.breakdownMode === "dow") {
        const order = [1,2,3,4,5,6,0];
        const labels = order.map(d => DOW_SHORT[d]);

        const moeData = order.map(d => (agg.perDow.get(d)?.Moe || 0));
        const trishData = order.map(d => (agg.perDow.get(d)?.Trish || 0));

        const datasets = (userInfo.users.length === 1)
          ? [{
              label: userInfo.users[0],
              data: (userInfo.users[0] === "Moe" ? moeData : trishData),
              backgroundColor: (userInfo.users[0] === "Moe" ? moeColor : trishColor),
              borderRadius: 12,
              borderSkipped: false
            }]
          : [
              { label: "Moe", data: moeData, backgroundColor: moeColor, borderRadius: 12, borderSkipped: false },
              { label: "Trish", data: trishData, backgroundColor: trishColor, borderRadius: 12, borderSkipped: false }
            ];

        el.queryChartWrap.classList.remove("hidden");
        queryChart = new window.Chart(el.queryChartCanvas, {
          type: "bar",
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: commonPlugins,
            scales: {
              x: { grid: { display: false }, ticks: { color: textColor, font: { weight: "800" } } },
              y: { beginAtZero: true, grid: { display: false }, ticks: { color: textColor, font: { weight: "800" }, precision: 0 } }
            },
            animation: { duration: 450 }
          }
        });
        return;
      }

      const bucketed = buildTimeBucketsFromPerDay(agg.perDay, range);
      if (!bucketed.labels.length) return;

      const datasets = (userInfo.users.length === 1)
        ? [{
            label: userInfo.users[0],
            data: bucketed.series.map(s => s[userInfo.users[0]] || 0),
            backgroundColor: (userInfo.users[0] === "Moe") ? moeColor : trishColor,
            borderRadius: 12,
            borderSkipped: false
          }]
        : [
            { label: "Moe", data: bucketed.series.map(s => s.Moe || 0), backgroundColor: moeColor, borderRadius: 12, borderSkipped: false },
            { label: "Trish", data: bucketed.series.map(s => s.Trish || 0), backgroundColor: trishColor, borderRadius: 12, borderSkipped: false }
          ];

      el.queryChartWrap.classList.remove("hidden");
      queryChart = new window.Chart(el.queryChartCanvas, {
        type: "bar",
        data: { labels: bucketed.labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: commonPlugins,
          scales: {
            x: { grid: { display: false }, ticks: { color: textColor, font: { weight: "800" }, maxRotation: 0, autoSkip: true } },
            y: { beginAtZero: true, grid: { display: false }, ticks: { color: textColor, font: { weight: "800" }, precision: 0 } }
          },
          animation: { duration: 450 }
        }
      });
    }

    // PH0-4: buildTimeBucketsFromPerDay uses weekKeyFromDayKey (NY Monday weeks)
    function buildTimeBucketsFromPerDay(perDayMap, range) {
      const startDayKey = range.startDayKey;
      const endDayKeyInclusive = dayKeyAddDays(range.endDayKeyExclusive, -1);
      const spanDays = calcRangeSpanDays(range);

      let mode = "day";
      if (spanDays > 90) mode = "month";
      else if (spanDays > 30) mode = "week";

      const bucketKeys = [];
      const labels = [];
      const bucketMap = new Map();

      function ensureBucket(key, label) {
        if (!bucketMap.has(key)) bucketMap.set(key, { Moe: 0, Trish: 0, total: 0 });
        bucketKeys.push(key);
        labels.push(label);
      }

      if (mode === "day") {
        let dk = startDayKey;
        while (dk <= endDayKeyInclusive) {
          ensureBucket(dk, labelForDay(dk));
          dk = dayKeyAddDays(dk, 1);
        }
      } else if (mode === "week") {
        let wk = weekKeyFromDayKey(startDayKey);
        const endWk = weekKeyFromDayKey(endDayKeyInclusive);
        while (wk <= endWk) {
          ensureBucket(wk, labelForWeek(wk));
          wk = dayKeyAddDays(wk, 7);
        }
      } else {
        let mk = monthKeyFromDayKey(startDayKey);
        const endMk = monthKeyFromDayKey(endDayKeyInclusive);
        while (mk <= endMk) {
          ensureBucket(mk, labelForMonth(mk));
          mk = addMonthsToMonthKey(mk, 1);
        }
      }

      for (const [dayKey, rec] of perDayMap.entries()) {
        if (dayKey < startDayKey || dayKey > endDayKeyInclusive) continue;

        let key;
        if (mode === "day") key = dayKey;
        else if (mode === "week") key = weekKeyFromDayKey(dayKey);
        else key = monthKeyFromDayKey(dayKey);

        if (!bucketMap.has(key)) continue;
        const b = bucketMap.get(key);
        b.Moe += rec.Moe || 0;
        b.Trish += rec.Trish || 0;
        b.total += rec.total || 0;
      }

      const series = bucketKeys.map(k => bucketMap.get(k) || { Moe: 0, Trish: 0, total: 0 });
      return { mode, labels, series, spanDays };
    }

    const EXAMPLES_HTML = `
      Try questions like:<small>
      How many drinks did Moe have today?<br>
      How many drinks did Trish have in December 2025?<br>
      How many drinks both last week?<br>
      Moe 12/1-12/15<br>
      Weekends last month<br>
      Fridays this year for Moe<br>
      Day by day last week
      </small>
    `;

    function handleQuery() {
      destroyQueryChart();

      const raw = (el.queryInput?.value || "").trim();
      const nowDayKey = currentDayKey();
      const todayDayKey = nowDayKey;
      const tomorrowDayKey = dayKeyAddDays(todayDayKey, 1);

      if (!raw) {
        setQueryResult(EXAMPLES_HTML, false);
        return;
      }

      const qLower = normalizeQuery(raw);
      const intent = parseIntent(qLower);
      const userInfo = parseUsers(qLower, intent);
      const dayFilter = parseDayFilter(qLower);

      const preferCalendarLastWeek = !!(dayFilter && /\blast week\b/.test(qLower));
      const range = resolveTimeRange(raw, nowDayKey, { preferCalendarLastWeek });

      if (!range) {
        setQueryResult(
          `Sorry - I could not find a time range in that question.<small>
          Try: today, yesterday, last week, calendar last week, past 7 days, last month, this year, or an explicit range like 12/1-12/15.
          </small>`,
          false
        );
        return;
      }

      // Future start in NY calendar terms
      if (range.startDayKey > todayDayKey) {
        setQueryResult(
          `That time range starts in the future (${fmtDayKey(range.startDayKey)}).<small>
          Try "last weekend" or "last Friday" for past results.
          </small>`,
          false
        );
        return;
      }

      // Cap open-ended ranges to include "today" at most
      const cappedRange = {
        ...range,
        endDayKeyExclusive: (range.endDayKeyExclusive > tomorrowDayKey) ? tomorrowDayKey : range.endDayKeyExclusive
      };

      const filters = { dayFilter };
      const agg = aggregate(userInfo.users, cappedRange, filters);

      const moeN = agg.sums["Moe"] || 0;
      const trishN = agg.sums["Trish"] || 0;

      const rangeText = fmtRangeDayKeys(cappedRange.startDayKey, cappedRange.endDayKeyExclusive);
      const filterText = dayFilter ? `, filter: ${dayFilter.label}` : "";
      const meta = `<small>Range used: ${rangeText}${filterText}</small>`;

      function finish(html, ok) {
        setQueryResult(html, ok);
        if (ok) renderChart(intent, userInfo, agg, cappedRange);
      }

      if (intent.type === "comparison") {
        const isWhoDrank = intent.whoSignals && !(/\bmore\b|\bmost\b|\bwinner\b|\bvs\b|\bversus\b|\bcompare\b/.test(qLower));

        if (isWhoDrank) {
          const who = [];
          if (moeN > 0) who.push(`Moe (${moeN})`);
          if (trishN > 0) who.push(`Trish (${trishN})`);
          if (who.length === 0) finish(`No drinks logged in ${cappedRange.label}.${meta}`, true);
          else if (who.length === 1) finish(`${who[0]} logged drinks in ${cappedRange.label}.${meta}`, true);
          else finish(`${who.join(" and ")} logged drinks in ${cappedRange.label}.${meta}`, true);
          return;
        }

        const leader = moeN === trishN ? null : (moeN > trishN ? "Moe" : "Trish");
        if (!leader) {
          finish(`Tie - Moe and Trish both had ${moeN} ${plural(moeN, "drink")} in ${cappedRange.label}.${meta}`, true);
          return;
        }

        const a = leader === "Moe" ? moeN : trishN;
        const b = leader === "Moe" ? trishN : moeN;

        const yesNo = /\bdid\b/.test(qLower) && (/\bmore than\b|\bless than\b/.test(qLower));
        if (yesNo) {
          const askedTrishMore = /\btrish\b.*\bmore than\b.*\bmoe\b|\bmore than\b.*\bmoe\b.*\btrish\b/.test(qLower) || /\btrish\b.*\bmore than\b/.test(qLower);
          const trishMore = trishN > moeN;
          const answer = askedTrishMore ? (trishMore ? "Yes" : "No") : (trishMore ? "No" : "Yes");
          finish(`${answer} - Moe: ${moeN}, Trish: ${trishN} in ${cappedRange.label}.${meta}`, true);
          return;
        }

        finish(`${leader} had more drinks than ${leader === "Moe" ? "Trish" : "Moe"} in ${cappedRange.label} (${a} vs ${b}).${meta}`, true);
        return;
      }

      if (intent.type === "difference") {
        const diff = Math.abs(moeN - trishN);
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          const n = agg.sums[u] || 0;
          finish(`${u} had ${n} ${plural(n, "drink")} in ${cappedRange.label}.${meta}`, true);
          return;
        }
        const leader = moeN === trishN ? null : (moeN > trishN ? "Moe" : "Trish");
        if (!leader) {
          finish(`Difference is 0 - Moe and Trish are tied at ${moeN} in ${cappedRange.label}.${meta}`, true);
          return;
        }
        finish(`${leader} led by ${diff} ${plural(diff, "drink")} in ${cappedRange.label} (Moe ${moeN} vs Trish ${trishN}).${meta}`, true);
        return;
      }

      if (intent.type === "average") {
        const daysCount = daysTouchedByRange(cappedRange);
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          const n = agg.sums[u] || 0;
          const avg = n / daysCount;
          finish(`${u} averaged ${avg.toFixed(2)} drinks per day in ${cappedRange.label} (${n} total over ${daysCount} ${plural(daysCount, "day")}).${meta}`, true);
          return;
        }
        const total = agg.total || 0;
        const avg = total / daysCount;
        finish(`Average ${avg.toFixed(2)} drinks per day in ${cappedRange.label} (${total} total over ${daysCount} ${plural(daysCount, "day")}).<br>Moe ${moeN}, Trish ${trishN}.${meta}`, true);
        return;
      }

      if (intent.type === "days_count") {
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          const d = agg.daySets[u]?.size || 0;
          finish(`${u} logged drinks on ${d} ${plural(d, "day")} in ${cappedRange.label}.${meta}`, true);
          return;
        }
        const dM = agg.daySets["Moe"]?.size || 0;
        const dT = agg.daySets["Trish"]?.size || 0;
        finish(`Days with drinks in ${cappedRange.label}: Moe ${dM}, Trish ${dT}.${meta}`, true);
        return;
      }

      if (intent.type === "peak_day") {
        let bestDayKey = null;
        let bestVal = -Infinity;

        for (const [dayKey, rec] of agg.perDay.entries()) {
          const val = (userInfo.users.length === 1)
            ? (rec[userInfo.users[0]] || 0)
            : (rec.total || 0);
          if (val > bestVal) { bestVal = val; bestDayKey = dayKey; }
        }

        if (bestDayKey === null || bestVal <= 0) {
          finish(`No drinks logged in ${cappedRange.label}.${meta}`, true);
          return;
        }

        const when = fmtDayKey(bestDayKey);
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          finish(`${u}'s peak day in ${cappedRange.label} was ${when} with ${bestVal} ${plural(bestVal, "drink")}.${meta}`, true);
          return;
        }

        const rec = agg.perDay.get(bestDayKey);
        finish(`Peak day in ${cappedRange.label} was ${when} with ${bestVal} ${plural(bestVal, "drink")} total.<br>Moe ${rec.Moe || 0}, Trish ${rec.Trish || 0}.${meta}`, true);
        return;
      }

      if (intent.type === "breakdown") {
        const mode = intent.breakdownMode || "date";

        if (mode === "dow") {
          const order = [1,2,3,4,5,6,0];
          const lines = [];
          for (const dow of order) {
            const rec = agg.perDow.get(dow) || { Moe: 0, Trish: 0, total: 0 };
            if (userInfo.users.length === 1) {
              const u = userInfo.users[0];
              lines.push(`${DOW_SHORT[dow]}: ${rec[u] || 0}`);
            } else {
              lines.push(`${DOW_SHORT[dow]}: ${rec.total || 0}`);
            }
          }
          const header = (userInfo.users.length === 1)
            ? `${userInfo.users[0]} breakdown by day of week in ${cappedRange.label}:`
            : `Total breakdown by day of week in ${cappedRange.label}:`;

          finish(`${header}<br>${lines.join(" | ")}${meta}`, true);
          return;
        }

        const days = Array.from(agg.perDay.entries()).sort((a, b) => a[0].localeCompare(b[0]));
        if (days.length === 0) {
          finish(`No drinks logged in ${cappedRange.label}.${meta}`, true);
          return;
        }

        const maxLines = 10;
        const shown = days.slice(-maxLines);
        const rows = shown.map(([dayKey, rec]) => {
          const p = parseDayKey(dayKey);
          const dayLabel = `${monthNameFromIndex(p.month - 1).slice(0,3)} ${p.day}`;
          if (userInfo.users.length === 1) {
            const u = userInfo.users[0];
            return `${dayLabel}: ${rec[u] || 0}`;
          }
          return `${dayLabel}: Moe ${rec.Moe || 0}, Trish ${rec.Trish || 0}, total ${rec.total || 0}`;
        });

        const header = (days.length > maxLines)
          ? `Day-by-day (showing last ${maxLines} days in range) for ${cappedRange.label}:`
          : `Day-by-day for ${cappedRange.label}:`;

        finish(`${header}<br>${rows.join("<br>")}${meta}`, true);
        return;
      }

      if (userInfo.mode === "who") {
        const who = [];
        if (moeN > 0) who.push(`Moe (${moeN})`);
        if (trishN > 0) who.push(`Trish (${trishN})`);
        if (who.length === 0) finish(`No drinks logged in ${cappedRange.label}.${meta}`, true);
        else finish(`${who.join(" and ")} logged drinks in ${cappedRange.label}.${meta}`, true);
        return;
      }

      if (userInfo.users.length === 1) {
        const u = userInfo.users[0];
        const n = agg.sums[u] || 0;
        finish(`${u} had ${n} ${plural(n, "drink")} in ${cappedRange.label}.${meta}`, true);
        return;
      }

      const total = agg.total || 0;
      finish(`Moe had ${moeN} ${plural(moeN, "drink")}, Trish had ${trishN} ${plural(trishN, "drink")}. Total ${total} ${plural(total, "drink")} in ${cappedRange.label}.${meta}`, true);
    }

    if (el.querySubmit) el.querySubmit.addEventListener("click", handleQuery);
    if (el.queryInput) el.queryInput.addEventListener("keydown", (e) => { if (e.key === "Enter") handleQuery(); });

    // PH0-4: renderHistoryChart uses NY dayKey selection (last 21 days)
    function renderHistoryChart() {
      destroyHistoryChart();

      if (!window.Chart || !el.historyChartCanvas || !el.historyChartWrap) return;

      const moeColor = cssVar("--moe", "#6ab7ff");
      const trishColor = cssVar("--trish", "#ff8da1");
      const textColor = cssVar("--text", "#544a4a");

      const todayDayKey = currentDayKey();
      const startDayKey = dayKeyAddDays(todayDayKey, -(21 - 1));
      const endDayKeyExclusive = dayKeyAddDays(todayDayKey, 1);
      const range = { startDayKey, endDayKeyExclusive, label: "last 21 days" };

      const agg = aggregate(["Moe", "Trish"], range, {});
      const bucketed = buildTimeBucketsFromPerDay(agg.perDay, range);

      const moeTotal = agg?.sums?.Moe || 0;
      const trishTotal = agg?.sums?.Trish || 0;
      if ((moeTotal + trishTotal) === 0 || !bucketed.labels.length) {
        if (el.historyChartWrap) el.historyChartWrap.classList.add("hidden");
        return;
      }

      const datasets = [
        { label: "Moe", data: bucketed.series.map(s => s.Moe || 0), backgroundColor: moeColor, borderRadius: 12, borderSkipped: false },
        { label: "Trish", data: bucketed.series.map(s => s.Trish || 0), backgroundColor: trishColor, borderRadius: 12, borderSkipped: false }
      ];

      el.historyChartWrap.classList.remove("hidden");
      historyChart = new window.Chart(el.historyChartCanvas, {
        type: "bar",
        data: { labels: bucketed.labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: "bottom",
              labels: { color: textColor, boxWidth: 14, boxHeight: 14, padding: 14, font: { weight: "800" } }
            },
            tooltip: {
              enabled: true,
              titleColor: "#fff",
              bodyColor: "#fff",
              callbacks: { labelTextColor: () => "#fff" }
            }
          },
          scales: {
            x: { grid: { display: false }, ticks: { color: textColor, font: { weight: "800" }, maxRotation: 0, autoSkip: true } },
            y: { beginAtZero: true, grid: { display: false }, ticks: { color: textColor, font: { weight: "800" }, precision: 0 } }
          },
          animation: { duration: 450 }
        }
      });
    }

    function switchTab(tab) {
      el.tabTracker.classList.toggle("active", tab === "tracker");
      el.tabAnalytics.classList.toggle("active", tab === "analytics");

      el.viewTracker.classList.toggle("hidden", tab !== "tracker");
      el.viewAnalytics.classList.toggle("hidden", tab !== "analytics");

      el.header.innerText = tab === "tracker" ? "Check in" : "History";
    }
    window.switchTab = switchTab;

    function startApp() {
      el.viewLogin.classList.add("hidden");
      el.nav.classList.remove("hidden");
      switchTab("tracker");

      if (el.queryText && el.queryText.innerHTML.trim() === "") {
        setQueryResult(EXAMPLES_HTML, false);
        destroyQueryChart();
      }
    }

    function login() {
      if (el.pass.value === "Moetrin") {
        localStorage.setItem("auth_token", "Moetrin");
        startApp();
      } else {
        alert("Wrong Password");
        el.pass.value = "";
      }
    }

    el.btnLogin.addEventListener("click", login);
    el.pass.addEventListener("keydown", (e) => { if (e.key === "Enter") login(); });

    function addDrink(user, amount) {
      const card = user === "Moe" ? el.cardMoe : el.cardTrish;

      if (amount > 0) {
        push(historyRef, { user, timestamp: Date.now(), value: 1 });

        const pop = document.createElement("div");
        pop.className = "kanpai-pop";
        pop.innerText = "üçª Kanpai!";
        card.appendChild(pop);
        setTimeout(() => pop.remove(), 800);
        return;
      }

      let lastId = null;
      let lastTime = 0;

      for (const [id, data] of Object.entries(allHistory || {})) {
        if (data && data.user === user && typeof data.timestamp === "number" && data.timestamp > lastTime) {
          lastTime = data.timestamp;
          lastId = id;
        }
      }

      if (lastId) {
        remove(ref(db, "history/" + lastId));
        card.style.transform = "translateX(5px)";
        setTimeout(() => (card.style.transform = "translateX(-5px)"), 50);
        setTimeout(() => (card.style.transform = "none"), 100);
      }
    }
    window.addDrink = addDrink;

    function updateText(id, val) {
      const node = document.getElementById(id);
      if (node) node.innerText = String(val);
    }

    // PH0-4: calculate uses NY dayKeys for day/week/month windows (no browser-local boundaries)
    function calculate() {
      const todayDayKey = currentDayKey();
      const tomorrowDayKey = dayKeyAddDays(todayDayKey, 1);
      const start7DayKey = dayKeyAddDays(todayDayKey, -(7 - 1));
      const start30DayKey = dayKeyAddDays(todayDayKey, -(30 - 1));

      const stats = {
        moe: { day: 0, week: 0, month: 0, all: 0 },
        trish: { day: 0, week: 0, month: 0, all: 0 }
      };

      for (const e of eventsCache) {
        const u = e.user?.toLowerCase();
        if (!u || !stats[u]) continue;

        stats[u].all += e.v;

        if (e.dayKey >= start30DayKey && e.dayKey < tomorrowDayKey) stats[u].month += e.v;
        if (e.dayKey >= start7DayKey && e.dayKey < tomorrowDayKey) stats[u].week += e.v;
        if (e.dayKey === todayDayKey) stats[u].day += e.v;
      }

      el.cMoe.innerText = stats.moe.day;
      el.cTrish.innerText = stats.trish.day;

      updateText("stat-day-moe", stats.moe.day);
      updateText("stat-day-trish", stats.trish.day);
      updateText("stat-week-moe", stats.moe.week);
      updateText("stat-week-trish", stats.trish.week);
      updateText("stat-month-moe", stats.moe.month);
      updateText("stat-month-trish", stats.trish.month);
      updateText("stat-all-moe", stats.moe.all);
      updateText("stat-all-trish", stats.trish.all);
    }

    onValue(historyRef, (snapshot) => {
      allHistory = snapshot.val() || {};
      rebuildEventsCache();
      calculate();
      renderHistoryChart();
    });

    if (localStorage.getItem("auth_token") === "Moetrin") startApp();
  </script>
</body>
</html>
