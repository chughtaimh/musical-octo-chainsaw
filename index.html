<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="M&T Drinks" />
  <title>M&T Drinks Tracker</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap" rel="stylesheet" />

  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23fdfbf7' rx='22'/%3E%3Crect x='15' y='35' width='25' height='35' rx='4' fill='%236ab7ff' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M40 40 C 50 40, 50 60, 40 60' fill='none' stroke='%23544a4a' stroke-width='3'/%3E%3Crect x='15' y='35' width='25' height='10' rx='2' fill='white' opacity='0.5'/%3E%3Cpath d='M60 35 Q 60 60 75 60 Q 90 60 90 35 Z' fill='%23ff8da1' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='75' y1='60' x2='75' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='65' y1='80' x2='85' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M50 20 L52 25 L57 27 L52 29 L50 34 L48 29 L43 27 L48 25 Z' fill='%23ffd700'/%3E%3C/svg%3E" />
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23fdfbf7' rx='22'/%3E%3Crect x='15' y='35' width='25' height='35' rx='4' fill='%236ab7ff' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M40 40 C 50 40, 50 60, 40 60' fill='none' stroke='%23544a4a' stroke-width='3'/%3E%3Crect x='15' y='35' width='25' height='10' rx='2' fill='white' opacity='0.5'/%3E%3Cpath d='M60 35 Q 60 60 75 60 Q 90 60 90 35 Z' fill='%23ff8da1' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='75' y1='60' x2='75' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cline x1='65' y1='80' x2='85' y2='80' stroke='%23544a4a' stroke-width='3'/%3E%3Cpath d='M50 20 L52 25 L57 27 L52 29 L50 34 L48 29 L43 27 L48 25 Z' fill='%23ffd700'/%3E%3C/svg%3E" />

  <style>
    :root { --bg: #fdfbf7; --card: #ffffff; --moe: #6ab7ff; --trish: #ff8da1; --text: #544a4a; --shadow: 0 8px 20px rgba(149, 157, 165, 0.15); }
    body {
      font-family: 'M PLUS Rounded 1c', sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
      overflow: hidden;
      background-image: radial-gradient(#ff8da1 1px, transparent 1px), radial-gradient(#6ab7ff 1px, transparent 1px);
      background-size: 40px 40px;
      background-position: 0 0, 20px 20px;
    }

    header {
      padding: 20px;
      text-align: center;
      font-weight: 800;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
      border-bottom: 2px solid #eee;
      color: var(--trish);
      font-size: 1.2rem;
      z-index: 10;
    }

    #app-content {
      flex: 1;
      padding: 25px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      position: relative;
      -webkit-overflow-scrolling: touch;
    }

    .hidden { display: none !important; }

    #view-login {
      display: flex;
      flex-direction: column;
      justify-content: center;
      height: 100%;
      text-align: center;
    }

    .login-card {
      background: white;
      padding: 30px;
      border-radius: 25px;
      box-shadow: var(--shadow);
    }

    input {
      padding: 15px;
      font-size: 1.2rem;
      border-radius: 50px;
      border: 2px solid #eee;
      background: #f9f9f9;
      text-align: center;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 15px;
      outline: none;
      transition: 0.2s;
    }
    input:focus { border-color: var(--trish); background: #fff; }

    .btn-main {
      padding: 15px;
      background: var(--trish);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      box-shadow: 0 4px 10px rgba(255, 141, 161, 0.4);
      transition: transform 0.1s;
    }
    .btn-main:active { transform: scale(0.95); }

    .user-card {
      background: var(--card);
      border-radius: 30px;
      padding: 20px;
      margin-bottom: 25px;
      text-align: center;
      border: 3px solid transparent;
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow: var(--shadow);
      position: relative;
    }

    .user-card.active-user {
      border-color: #ffd700;
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(255, 215, 0, 0.3);
    }
    .user-card.active-user::after {
      content: '‚≠ê';
      position: absolute;
      top: -15px;
      right: -10px;
      font-size: 2.5rem;
      animation: spin 3s infinite linear;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
    }

    .avatar { font-size: 3rem; display: block; margin-bottom: 5px; }
    .user-name { font-size: 1.1rem; font-weight: 800; text-transform: uppercase; color: #888; }
    .count {
      font-size: 5rem;
      font-weight: 800;
      line-height: 1;
      margin: 10px 0;
      color: var(--text);
      text-shadow: 2px 2px 0px #eee;
      font-variant-numeric: tabular-nums;
    }
    .moe .user-name { color: var(--moe); }
    .trish .user-name { color: var(--trish); }

    .controls { display: flex; justify-content: center; gap: 25px; margin-top: 15px; }
    .btn-round {
      width: 70px;
      height: 70px;
      border-radius: 25px;
      border: none;
      font-size: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 5px 0 rgba(0,0,0,0.1);
      transition: transform 0.1s;
      background: #f0f0f0;
      color: #888;
      touch-action: manipulation;
    }
    .btn-round:active { transform: translateY(4px); box-shadow: none; }
    .moe .plus { background: var(--moe); color: white; box-shadow: 0 5px 0 #4a90e2; }
    .trish .plus { background: var(--trish); color: white; box-shadow: 0 5px 0 #e06c80; }

    .analytics-container { background: white; border-radius: 25px; padding: 20px; box-shadow: var(--shadow); }
    .stats-table { width: 100%; border-collapse: collapse; }
    .stats-table th { text-align: left; color: #aaa; padding: 10px; font-size: 0.8rem; text-transform: uppercase; }
    .stats-table td { padding: 15px 10px; border-bottom: 2px dashed #f0f0f0; font-size: 1.2rem; font-weight: 800; }
    .val-moe { color: var(--moe); }
    .val-trish { color: var(--trish); }

    /* Natural language query UI */
    .query-container { background: white; border-radius: 25px; padding: 20px; box-shadow: var(--shadow); margin-top: 18px; }
    .query-row { display: flex; gap: 12px; align-items: stretch; flex-wrap: wrap; }
    #query-input { margin-bottom: 0; text-align: left; padding-left: 18px; padding-right: 18px; flex: 1 1 220px; }
    .btn-query {
      width: auto;
      min-width: 110px;
      padding: 14px 18px;
      font-size: 1.05rem;
      border-radius: 18px;
      box-shadow: 0 4px 10px rgba(255, 141, 161, 0.35);
      flex: 0 0 auto;
    }
    #query-results {
      margin-top: 14px;
      background: #f9f9f9;
      border: 2px dashed #eee;
      border-radius: 18px;
      padding: 14px;
      font-weight: 800;
      line-height: 1.35;
      min-height: 22px;
      text-align: center;
      white-space: normal;
    }
    #query-results.good { border-color: rgba(106, 183, 255, 0.35); }
    #query-results.bad { border-color: rgba(255, 141, 161, 0.45); }
    #query-results small { display: block; margin-top: 8px; font-weight: 700; color: #888; }

    #main-nav {
      background: white;
      border-top: 2px solid #eee;
      display: flex;
      padding-bottom: env(safe-area-inset-bottom);
      height: 80px;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.02);
      z-index: 10;
    }
    .nav-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ccc;
      font-size: 0.8rem;
      font-weight: 800;
      gap: 5px;
      transition: 0.2s;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .nav-item.active { color: var(--trish); transform: scale(1.1); }
    .nav-icon { font-size: 1.5rem; }

    @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(0.5); } 100% { opacity: 0; transform: translateY(-50px) scale(1.5); } }
    .kanpai-pop {
      position: absolute;
      font-weight: 900;
      color: #ffbf00;
      font-size: 2rem;
      pointer-events: none;
      animation: floatUp 0.8s ease-out forwards;
      z-index: 99;
      text-shadow: 2px 2px 0 #fff;
      width: 100%;
      text-align: center;
      left: 0;
      top: 20px;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
  </style>
</head>

<body>
  <header id="app-header">Welcome</header>

  <div id="app-content">
    <div id="view-login">
      <div class="login-card">
        <div style="font-size: 4rem; margin-bottom: 20px;">‚õ©Ô∏è</div>
        <h2 style="margin-bottom:10px; color: var(--trish);">Welcome Back!</h2>
        <input type="password" id="pass-input" placeholder="Password" />
        <button id="btn-login" class="btn-main">Start Tracker</button>
      </div>
    </div>

    <div id="view-tracker" class="hidden">
      <div style="text-align:center; margin-bottom:20px; color:#aaa; font-weight:bold;">TODAY'S SCORE</div>

      <div class="user-card moe" id="card-moe">
        <div class="avatar">üêª</div>
        <div class="user-name">Moe</div>
        <div class="count" id="c-moe">...</div>
        <div class="controls">
          <button class="btn-round" onclick="addDrink('Moe', -1)">‚àí</button>
          <button class="btn-round plus" onclick="addDrink('Moe', 1)">üç∫</button>
        </div>
      </div>

      <div class="user-card trish" id="card-trish">
        <div class="avatar">üê±</div>
        <div class="user-name">Trish</div>
        <div class="count" id="c-trish">...</div>
        <div class="controls">
          <button class="btn-round" onclick="addDrink('Trish', -1)">‚àí</button>
          <button class="btn-round plus" onclick="addDrink('Trish', 1)">üçπ</button>
        </div>
      </div>
    </div>

    <div id="view-analytics" class="hidden">
      <div class="analytics-container">
        <h3 style="text-align:center; color:var(--text); margin-top:0;">History Log</h3>
        <table class="stats-table">
          <thead>
            <tr><th>Period</th><th>üêª Moe</th><th>üê± Trish</th></tr>
          </thead>
          <tbody>
            <tr><td>Today</td><td class="val-moe" id="stat-day-moe">0</td><td class="val-trish" id="stat-day-trish">0</td></tr>
            <tr><td>7 Days</td><td class="val-moe" id="stat-week-moe">0</td><td class="val-trish" id="stat-week-trish">0</td></tr>
            <tr><td>30 Days</td><td class="val-moe" id="stat-month-moe">0</td><td class="val-trish" id="stat-month-trish">0</td></tr>
            <tr><td>All Time</td><td class="val-moe" id="stat-all-moe">0</td><td class="val-trish" id="stat-all-trish">0</td></tr>
          </tbody>
        </table>
      </div>

      <div class="query-container">
        <h3 style="text-align:center; color:var(--text); margin-top:0;">Ask the Log</h3>
        <div class="query-row">
          <input type="text" id="query-input" placeholder="Ask a question... (ex: Who had more drinks last week? Moe 12/1-12/15? Weekends last month?)" />
          <button id="query-submit" class="btn-main btn-query">Ask</button>
        </div>
        <div id="query-results"></div>
      </div>

      <div style="text-align:center; margin-top:40px; color:#aaa; font-size:0.8rem;">Ganbatte! (Do your best!)</div>
    </div>
  </div>

  <nav id="main-nav" class="hidden">
    <div class="nav-item active" id="tab-tracker" onclick="switchTab('tracker')">
      <span class="nav-icon">üìù</span><span>Tracker</span>
    </div>
    <div class="nav-item" id="tab-analytics" onclick="switchTab('analytics')">
      <span class="nav-icon">üìä</span><span>History</span>
    </div>
  </nav>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, onValue, push, remove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

    // --- Firebase ---
    const firebaseConfig = {
      apiKey: "AIzaSyDwjSeEdz3g6ofnvvURIr_Q_q0KII4QtdU",
      authDomain: "drinks-tracker-cb5e5.firebaseapp.com",
      databaseURL: "https://drinks-tracker-cb5e5-default-rtdb.firebaseio.com",
      projectId: "drinks-tracker-cb5e5",
      storageBucket: "drinks-tracker-cb5e5.firebasestorage.app",
      messagingSenderId: "670928393598",
      appId: "1:670928393598:web:1d3bf4c73fe8f7714d0f2f",
      measurementId: "G-36G1HBRE9K"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const historyRef = ref(db, "history");

    // --- DOM ---
    const el = {
      header: document.getElementById("app-header"),
      viewLogin: document.getElementById("view-login"),
      viewTracker: document.getElementById("view-tracker"),
      viewAnalytics: document.getElementById("view-analytics"),
      nav: document.getElementById("main-nav"),
      tabTracker: document.getElementById("tab-tracker"),
      tabAnalytics: document.getElementById("tab-analytics"),
      pass: document.getElementById("pass-input"),
      btnLogin: document.getElementById("btn-login"),

      cMoe: document.getElementById("c-moe"),
      cTrish: document.getElementById("c-trish"),
      cardMoe: document.getElementById("card-moe"),
      cardTrish: document.getElementById("card-trish"),

      queryInput: document.getElementById("query-input"),
      querySubmit: document.getElementById("query-submit"),
      queryResults: document.getElementById("query-results")
    };

    let allHistory = {};
    let eventsCache = []; // normalized events for fast querying

    const DAY_MS = 24 * 60 * 60 * 1000;

    const DOW_FULL = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
    const DOW_SHORT = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const DOW_ALIASES = {
      sun: 0, sunday: 0,
      mon: 1, monday: 1,
      tue: 2, tues: 2, tuesday: 2,
      wed: 3, weds: 3, wednesday: 3,
      thu: 4, thur: 4, thurs: 4, thursday: 4,
      fri: 5, friday: 5,
      sat: 6, saturday: 6
    };

    const monthMap = {
      january: 0, jan: 0,
      february: 1, feb: 1,
      march: 2, mar: 2,
      april: 3, apr: 3,
      may: 4,
      june: 5, jun: 5,
      july: 6, jul: 6,
      august: 7, aug: 7,
      september: 8, sep: 8, sept: 8,
      october: 9, oct: 9,
      november: 10, nov: 10,
      december: 11, dec: 11
    };

    const numberWords = {
      a: 1, an: 1, one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10,
      eleven: 11, twelve: 12, thirteen: 13, fourteen: 14, fifteen: 15, sixteen: 16, seventeen: 17, eighteen: 18, nineteen: 19, twenty: 20
    };

    function monthNameFromIndex(idx) {
      const names = ["January","February","March","April","May","June","July","August","September","October","November","December"];
      return names[idx] || "";
    }

    function plural(n, word) {
      return Math.abs(n) === 1 ? word : word + "s";
    }

    function setQueryResult(html, ok) {
      if (!el.queryResults) return;
      el.queryResults.classList.remove("good", "bad");
      el.queryResults.classList.add(ok ? "good" : "bad");
      el.queryResults.innerHTML = html;
    }

    function normalizeQuery(q) {
      return String(q || "")
        .toLowerCase()
        .replace(/[‚Äô]/g, "'")
        .replace(/\s+/g, " ")
        .trim();
    }

    function startOfDayLocal(dOrMs) {
      const x = new Date(dOrMs);
      x.setHours(0, 0, 0, 0);
      return x.getTime();
    }

    // ISO-style week start: Monday 00:00 local
    function startOfWeekMonday(dOrMs) {
      const dayStart = startOfDayLocal(dOrMs);
      const day = new Date(dayStart).getDay(); // 0 Sun, 1 Mon, ..., 6 Sat
      const diff = (day + 6) % 7; // Monday -> 0, Sunday -> 6
      return dayStart - diff * DAY_MS;
    }

    function fmtDate(ms) {
      try {
        const d = new Date(ms);
        const y = d.getFullYear();
        const m = monthNameFromIndex(d.getMonth()).slice(0, 3);
        const day = d.getDate();
        return `${m} ${day}, ${y}`;
      } catch {
        return "";
      }
    }

    function fmtRange(startMs, endMs, nowMs) {
      const safeEnd = Math.max(startMs, endMs);
      const endForDisplay = (safeEnd === nowMs) ? nowMs : (safeEnd - 1);
      const a = fmtDate(startMs);
      const b = fmtDate(endForDisplay);
      return a === b ? a : `${a} - ${b}`;
    }

    function parseNumber(qLower) {
      const m = qLower.match(/\b(\d{1,3}|a|an|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\b/);
      if (!m) return null;
      const t = m[1];
      if (/^\d+$/.test(t)) return parseInt(t, 10);
      return numberWords[t] ?? null;
    }

    // --- Rebuild normalized events cache whenever history changes ---
    function rebuildEventsCache() {
      const out = [];
      for (const entry of Object.values(allHistory || {})) {
        if (!entry) continue;
        const u = entry.user;
        const ts = entry.timestamp;
        if (typeof u !== "string" || typeof ts !== "number") continue;

        const v = (typeof entry.value === "number" && Number.isFinite(entry.value)) ? entry.value : 1;
        const dayStart = startOfDayLocal(ts);
        const dow = new Date(dayStart).getDay();
        out.push({ user: u, ts, v, dayStart, dow });
      }
      out.sort((a, b) => a.ts - b.ts);
      eventsCache = out;
    }

    // --- Intent parsing ---
    function parseIntent(qLower) {
      const wantsDaysCount = /\bhow many days\b|\bnumber of days\b|\bdays did\b/.test(qLower);
      const wantsAvg = /\baverage\b|\bavg\b|\bper day\b|\bdaily average\b/.test(qLower);
      const wantsDiff = /\bdifference\b|\bdiff\b|\bdelta\b|\bby how many\b|\bmargin\b/.test(qLower);
      const wantsBreakdownByDow = /\bday of week\b|\bby day of week\b|\bweekday breakdown\b/.test(qLower);
      const wantsBreakdownByDate = /\bday by day\b|\beach day\b|\bdaily breakdown\b|\bper day\b(?!.*average)/.test(qLower);
      const wantsPeakDay = /\bpeak\b|\bhighest\b|\bmax\b|\bmost in a day\b|\bbiggest day\b|\bwhat day\b.*\bmost\b/.test(qLower);

      const compareSignals =
        /\bvs\b|\bversus\b|\bcompare\b|\bwho (won|wins|had more|drank more)\b|\bmore than\b|\bless than\b|\bbeat\b|\bwinner\b/.test(qLower) ||
        (/\bwho\b/.test(qLower) && /\bmore\b|\bmost\b/.test(qLower));

      // "Who drank yesterday?" style
      const whoSignals = /^\s*who\b/.test(qLower) || /\bwho drank\b|\bwho had\b/.test(qLower);

      let type = "count";
      if (wantsPeakDay) type = "peak_day";
      else if (wantsDaysCount) type = "days_count";
      else if (wantsAvg) type = "average";
      else if (wantsDiff) type = "difference";
      else if (compareSignals) type = "comparison";
      else if (wantsBreakdownByDow || wantsBreakdownByDate) type = "breakdown";

      const breakdownMode = wantsBreakdownByDow ? "dow" : (wantsBreakdownByDate ? "date" : null);

      return { type, breakdownMode, whoSignals };
    }

    // --- User parsing ---
    function parseUsers(qLower, intent) {
      const hasMoe = /\bmoe\b/.test(qLower) || /\bme\b/.test(qLower) || /\bmy\b/.test(qLower);
      const hasTrish = /\btrish\b/.test(qLower);

      const bothSignals = /\b(both|all|together|us|we|everyone)\b/.test(qLower) || (hasMoe && hasTrish);

      if (bothSignals) return { users: ["Moe", "Trish"], mode: "both" };
      if (hasMoe) return { users: ["Moe"], mode: "single" };
      if (hasTrish) return { users: ["Trish"], mode: "single" };

      // If the question is "who..." and user not specified, we want a who-style answer.
      if (intent.whoSignals) return { users: ["Moe", "Trish"], mode: "who" };

      // Default: both (higher answer rate)
      return { users: ["Moe", "Trish"], mode: "both" };
    }

    // --- Day-of-week filter parsing (weekends, weekdays, Wed-Fri, Fridays) ---
    function expandDowRange(d1, d2) {
      // Expand in Monday-based order: Mon(1) -> ... -> Sun(0) at end
      const order = [1,2,3,4,5,6,0];
      const i1 = order.indexOf(d1);
      const i2 = order.indexOf(d2);
      if (i1 === -1 || i2 === -1) return null;

      const out = [];
      if (i2 >= i1) {
        for (let i = i1; i <= i2; i++) out.push(order[i]);
      } else {
        // wrap
        for (let i = i1; i < order.length; i++) out.push(order[i]);
        for (let i = 0; i <= i2; i++) out.push(order[i]);
      }
      return out;
    }

    function parseDayFilter(qLower) {
      // Weekend(s) and weekday(s)
      if (/\bweekends?\b/.test(qLower) || /\bweek end(s)?\b/.test(qLower)) {
        return { days: [6, 0], label: "weekends" };
      }
      if (/\bweekdays?\b/.test(qLower)) {
        return { days: [1,2,3,4,5], label: "weekdays" };
      }

      // Day ranges like "wed-fri", "wednesday to friday", "mon thru thu"
      const rangeMatch = qLower.match(/\b(mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)\b\s*(?:-|to|thru|through)\s*\b(mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)\b/);
      if (rangeMatch) {
        const a = rangeMatch[1].replace(/sday|nesday|rsday|urday/g, "");
        const b = rangeMatch[2].replace(/sday|nesday|rsday|urday/g, "");
        const d1 = DOW_ALIASES[a] ?? null;
        const d2 = DOW_ALIASES[b] ?? null;
        const days = (d1 !== null && d2 !== null) ? expandDowRange(d1, d2) : null;
        if (days && days.length) return { days, label: `${DOW_SHORT[d1]}-${DOW_SHORT[d2]}` };
      }

      // Plural days like "fridays", "mondays"
      const pluralMatch = qLower.match(/\b(sundays|mondays|tuesdays|wednesdays|thursdays|fridays|saturdays)\b/);
      if (pluralMatch) {
        const token = pluralMatch[1].slice(0, -1); // remove trailing s
        const dow = DOW_ALIASES[token] ?? null;
        if (dow !== null) return { days: [dow], label: pluralMatch[1] };
      }

      return null;
    }

    // --- Date parsing helpers ---
    function inferYearForMonthDay(monthIdx, day, now, opts = {}) {
      const nowY = now.getFullYear();
      const todayStart = startOfDayLocal(now);

      const hasNext = !!opts.hasNext;
      const hasThis = !!opts.hasThis;

      let y = nowY;
      let candidate = new Date(y, monthIdx, day, 0, 0, 0, 0).getTime();

      if (hasNext) {
        if (candidate <= todayStart) y = nowY + 1;
        return y;
      }

      if (hasThis) {
        return nowY;
      }

      // Default: prefer past if the date would be in the future.
      if (candidate > todayStart) y = nowY - 1;
      return y;
    }

    function parseDateStringToDayStart(dateStr, now, qLower) {
      const s = String(dateStr || "").trim().toLowerCase();
      const hasNext = /\bnext\b/.test(qLower);
      const hasThis = /\bthis\b/.test(qLower) || /\bcurrent\b/.test(qLower);

      // ISO: YYYY-MM-DD
      let m = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (m) {
        const y = parseInt(m[1], 10);
        const mo = parseInt(m[2], 10) - 1;
        const d = parseInt(m[3], 10);
        const dt = new Date(y, mo, d, 0, 0, 0, 0);
        return isNaN(dt.getTime()) ? null : dt.getTime();
      }

      // Slash: M/D(/YYYY)
      m = s.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?$/);
      if (m) {
        const mo = parseInt(m[1], 10) - 1;
        const d = parseInt(m[2], 10);
        let y;
        if (m[3]) {
          y = parseInt(m[3], 10);
          if (y < 100) y = 2000 + y;
        } else {
          y = inferYearForMonthDay(mo, d, now, { hasNext, hasThis });
        }
        const dt = new Date(y, mo, d, 0, 0, 0, 0);
        return isNaN(dt.getTime()) ? null : dt.getTime();
      }

      // Month name: "dec 5 2025" or "december 5"
      m = s.match(/^(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:\s*,?\s*(\d{4}))?$/);
      if (m) {
        const monthToken = m[1];
        const mo = monthMap[monthToken] ?? null;
        if (mo === null) return null;
        const d = parseInt(m[2], 10);
        const y = m[3] ? parseInt(m[3], 10) : inferYearForMonthDay(mo, d, now, { hasNext, hasThis });
        const dt = new Date(y, mo, d, 0, 0, 0, 0);
        return isNaN(dt.getTime()) ? null : dt.getTime();
      }

      // Day month: "5 dec 2025"
      m = s.match(/^(\d{1,2})\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\s*,?\s*(\d{4}))?$/);
      if (m) {
        const d = parseInt(m[1], 10);
        const monthToken = m[2];
        const mo = monthMap[monthToken] ?? null;
        if (mo === null) return null;
        const y = m[3] ? parseInt(m[3], 10) : inferYearForMonthDay(mo, d, now, { hasNext, hasThis });
        const dt = new Date(y, mo, d, 0, 0, 0, 0);
        return isNaN(dt.getTime()) ? null : dt.getTime();
      }

      return null;
    }

    function extractDateTokens(qLower, now) {
      const tokens = [];

      function addToken(text, idx) {
        const dayStart = parseDateStringToDayStart(text, now, qLower);
        if (dayStart === null) return;
        tokens.push({ text, idx, len: text.length, dayStart });
      }

      // ISO tokens
      for (const match of qLower.matchAll(/\b(19\d{2}|20\d{2})-(\d{1,2})-(\d{1,2})\b/g)) {
        addToken(match[0], match.index ?? 0);
      }

      // Slash tokens
      for (const match of qLower.matchAll(/\b(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?\b/g)) {
        addToken(match[0], match.index ?? 0);
      }

      // Month name + day tokens
      for (const match of qLower.matchAll(/\b(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:\s*,?\s*(\d{4}))?\b/g)) {
        addToken(match[0], match.index ?? 0);
      }

      // Day + month name tokens
      for (const match of qLower.matchAll(/\b(\d{1,2})\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\s*,?\s*(\d{4}))?\b/g)) {
        addToken(match[0], match.index ?? 0);
      }

      // De-dupe by index
      const seen = new Set();
      const deduped = [];
      for (const t of tokens.sort((a, b) => a.idx - b.idx)) {
        const k = `${t.idx}:${t.len}:${t.dayStart}`;
        if (seen.has(k)) continue;
        seen.add(k);
        deduped.push(t);
      }
      return deduped;
    }

    // --- Month range parsing ---
    function parseMonthRange(qLower, now) {
      // Avoid false positives for "may" unless context is clear.
      let monthIdx = null;
      let matchedToken = null;

      for (const [token, idx] of Object.entries(monthMap)) {
        const re = new RegExp("\\b" + token + "\\b", "i");

        if (token === "may") {
          // Require context for may: "in may", "may 2025", "may 5"
          const ok = /\bin may\b/.test(qLower) || /\bmay\s+\d{4}\b/.test(qLower) || /\bmay\s+\d{1,2}\b/.test(qLower);
          if (!ok) continue;
        }

        if (re.test(qLower)) { monthIdx = idx; matchedToken = token; break; }
      }

      if (monthIdx === null) return null;

      // Explicit year
      const yearMatch = qLower.match(/\b(19\d{2}|20\d{2})\b/);
      const nowY = now.getFullYear();
      const nowM = now.getMonth();
      const hasNext = /\bnext\b/.test(qLower);
      const hasLast = /\blast\b|\bprevious\b/.test(qLower);
      const hasThis = /\bthis\b|\bcurrent\b/.test(qLower);

      let year;
      if (yearMatch) {
        year = parseInt(yearMatch[1], 10);
      } else if (hasNext) {
        year = (monthIdx <= nowM) ? nowY + 1 : nowY;
      } else if (hasLast) {
        year = (monthIdx >= nowM) ? nowY - 1 : nowY;
      } else if (hasThis) {
        year = nowY;
      } else {
        // Default: if month is ahead of current month, assume last year (more useful for logs)
        year = (monthIdx > nowM) ? nowY - 1 : nowY;
      }

      const start = new Date(year, monthIdx, 1, 0, 0, 0, 0).getTime();
      const end = new Date(year, monthIdx + 1, 1, 0, 0, 0, 0).getTime();
      return { startMs: start, endMs: end, label: `${monthNameFromIndex(monthIdx)} ${year}` };
    }

    // --- Named / relative range parsing ---
    function parseNamedRange(qLower, now, ctx) {
      const nowMs = now.getTime();
      const todayStart = startOfDayLocal(now);

      // Today / yesterday
      if (/\btoday\b/.test(qLower)) {
        return { startMs: todayStart, endMs: nowMs, label: "today" };
      }
      if (/\byesterday\b/.test(qLower)) {
        return { startMs: todayStart - DAY_MS, endMs: todayStart, label: "yesterday" };
      }

      // This week (calendar week starting Monday)
      if (/\bthis week\b/.test(qLower)) {
        return { startMs: startOfWeekMonday(now), endMs: nowMs, label: "this week" };
      }

      // "Calendar last week" or "previous week" (previous Mon-Sun)
      if (/\b(calendar last week|previous week|last calendar week)\b/.test(qLower)) {
        const startThis = startOfWeekMonday(now);
        return { startMs: startThis - 7 * DAY_MS, endMs: startThis, label: "last week (Mon-Sun)" };
      }

      // "Last week" default (common user meaning): past 7 days (calendar-day anchored)
      if (/\blast week\b/.test(qLower)) {
        // If the query includes explicit day-of-week filtering (Wed-Fri last week),
        // treat last week as the previous Mon-Sun to match typical phrasing.
        if (ctx?.preferCalendarLastWeek) {
          const startThis = startOfWeekMonday(now);
          return { startMs: startThis - 7 * DAY_MS, endMs: startThis, label: "last week (Mon-Sun)" };
        }
        return { startMs: todayStart - 6 * DAY_MS, endMs: nowMs, label: "last week (past 7 days)" };
      }

      // This month / last month (calendar)
      if (/\bthis month\b/.test(qLower)) {
        const start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0).getTime();
        return { startMs: start, endMs: nowMs, label: "this month" };
      }
      if (/\blast month\b/.test(qLower)) {
        const startThis = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0).getTime();
        const startPrev = new Date(now.getFullYear(), now.getMonth() - 1, 1, 0, 0, 0, 0).getTime();
        return { startMs: startPrev, endMs: startThis, label: "last month" };
      }

      // This year / last year (calendar)
      if (/\bthis year\b/.test(qLower) || /\bcurrent year\b/.test(qLower) || /\bytd\b/.test(qLower)) {
        const start = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0).getTime();
        return { startMs: start, endMs: nowMs, label: "this year" };
      }
      if (/\blast year\b|\bprevious year\b/.test(qLower)) {
        const startThis = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0).getTime();
        const startPrev = new Date(now.getFullYear() - 1, 0, 1, 0, 0, 0, 0).getTime();
        return { startMs: startPrev, endMs: startThis, label: "last year" };
      }

      // This weekend / last weekend (Sat-Sun)
      if (/\blast weekend\b/.test(qLower)) {
        const weekStart = startOfWeekMonday(now);
        const satThisWeek = weekStart + 5 * DAY_MS;
        const satLastWeek = satThisWeek - 7 * DAY_MS;
        const end = satLastWeek + 2 * DAY_MS; // Monday 00:00 after weekend
        return { startMs: satLastWeek, endMs: end, label: "last weekend" };
      }
      if (/\bthis weekend\b/.test(qLower)) {
        const weekStart = startOfWeekMonday(now);
        const satThisWeek = weekStart + 5 * DAY_MS;
        const end = satThisWeek + 2 * DAY_MS;
        // If weekend is in the future, return it anyway (will likely be 0).
        return { startMs: satThisWeek, endMs: Math.min(end, nowMs), label: "this weekend" };
      }

      // Specific weekday references: "last friday", "this tuesday", "next monday"
      const wd = qLower.match(/\b(last|this|next)\s+(sun(?:day)?|mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?)\b/);
      if (wd) {
        const mod = wd[1];
        const raw = wd[2].replace(/sday|nesday|rsday|urday/g, "");
        const target = DOW_ALIASES[raw];
        if (target === undefined || target === null) return null;

        const todayDow = new Date(todayStart).getDay();

        // Fix: "last Tuesday" should mean the most recent Tuesday BEFORE today (not "previous calendar week")
        if (mod === "last") {
          let diff = (todayDow - target + 7) % 7;
          if (diff === 0) diff = 7; // if today is Tuesday, "last Tuesday" = 7 days ago
          const dayStart = todayStart - diff * DAY_MS;
          return { startMs: dayStart, endMs: dayStart + DAY_MS, label: `last ${DOW_FULL[target]}` };
        }

        // Keep "this" and "next" anchored to the calendar week (Mon-Sun)
        const weekStart = startOfWeekMonday(now);
        const offset = (target + 6) % 7; // Mon=0 ... Sun=6
        const dayStart = weekStart + offset * DAY_MS;

        if (mod === "this") {
          return { startMs: dayStart, endMs: dayStart + DAY_MS, label: `this ${DOW_FULL[target]}` };
        }

        // next
        return { startMs: dayStart + 7 * DAY_MS, endMs: dayStart + 8 * DAY_MS, label: `next ${DOW_FULL[target]}` };
      }

      // "On Friday" (most recent occurrence, including today if it matches)
      const onWd = qLower.match(/\bon\s+(sun(?:day)?|mon(?:day)?|tue(?:s|sday|sday)?|tues(?:day)?|wed(?:s|nesday)?|thu(?:r|rs|rsday|rsday)?|thurs(?:day)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?)\b/);
      if (onWd) {
        const raw = onWd[1].replace(/sday|nesday|rsday|urday/g, "");
        const target = DOW_ALIASES[raw];
        const todayDow = new Date(todayStart).getDay();
        const diff = (todayDow - target + 7) % 7;
        const dayStart = todayStart - diff * DAY_MS;
        return { startMs: dayStart, endMs: dayStart + DAY_MS, label: `on ${DOW_FULL[target]}` };
      }

      return null;
    }

    function parseNumericRelative(qLower, now) {
      const nowMs = now.getTime();
      const todayStart = startOfDayLocal(now);

      // past/last N days
      const days = qLower.match(/\b(past|last)\s+(\d{1,3}|a|an|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\s+days?\b/);
      if (days) {
        const n = /^\d+$/.test(days[2]) ? parseInt(days[2], 10) : (numberWords[days[2]] ?? 1);
        const nn = Math.max(1, n);
        // Calendar anchored: includes today as day 1
        return { startMs: todayStart - (nn - 1) * DAY_MS, endMs: nowMs, label: `past ${nn} ${plural(nn, "day")}` };
      }

      // past/last N weeks (treated as N*7 days, calendar anchored)
      const weeks = qLower.match(/\b(past|last)\s+(\d{1,2}|a|an|one|two|three|four|five|six|seven|eight)\s+weeks?\b/);
      if (weeks) {
        const n = /^\d+$/.test(weeks[2]) ? parseInt(weeks[2], 10) : (numberWords[weeks[2]] ?? 1);
        const nn = Math.max(1, n);
        const daysCount = nn * 7;
        return { startMs: todayStart - (daysCount - 1) * DAY_MS, endMs: nowMs, label: `past ${nn} ${plural(nn, "week")}` };
      }

      // past/last N months (approx 30-day blocks, calendar anchored)
      const months = qLower.match(/\b(past|last)\s+(\d{1,2}|a|an|one|two|three|four|five|six)\s+months?\b/);
      if (months) {
        const n = /^\d+$/.test(months[2]) ? parseInt(months[2], 10) : (numberWords[months[2]] ?? 1);
        const nn = Math.max(1, n);
        const daysCount = nn * 30;
        return { startMs: todayStart - (daysCount - 1) * DAY_MS, endMs: now.getTime(), label: `past ${nn} ${plural(nn, "month")}` };
      }

      // Shorthand "last 7 days", "last 30 days"
      const nDays = qLower.match(/\blast\s+(7|30)\s+days?\b/);
      if (nDays) {
        const nn = parseInt(nDays[1], 10);
        return { startMs: todayStart - (nn - 1) * DAY_MS, endMs: nowMs, label: `past ${nn} days` };
      }

      return null;
    }

    // --- Explicit date range parsing ---
    function resolveTimeRange(rawQ, now, ctx) {
      const qLower = normalizeQuery(rawQ);
      const nowMs = now.getTime();
      const todayStart = startOfDayLocal(now);

      const dayFilter = parseDayFilter(qLower);
      const dateTokens = extractDateTokens(qLower, now);

      // Since DATE
      if (/\bsince\b/.test(qLower) && dateTokens.length >= 1) {
        // Pick the first date after "since" if possible
        const sinceIdx = qLower.indexOf("since");
        const t = dateTokens.find(x => x.idx >= sinceIdx) || dateTokens[0];
        return { startMs: t.dayStart, endMs: nowMs, label: `since ${fmtDate(t.dayStart)}` };
      }

      // On DATE (single day)
      if (/\bon\b/.test(qLower) && dateTokens.length >= 1) {
        const onIdx = qLower.indexOf("on");
        const t = dateTokens.find(x => x.idx >= onIdx) || dateTokens[0];
        return { startMs: t.dayStart, endMs: t.dayStart + DAY_MS, label: `on ${fmtDate(t.dayStart)}` };
      }

      // Between DATE and DATE
      if (/\bbetween\b/.test(qLower) && dateTokens.length >= 2) {
        const betweenIdx = qLower.indexOf("between");
        const andIdx = qLower.indexOf(" and ", betweenIdx);
        const t1 = dateTokens.find(x => x.idx >= betweenIdx) || dateTokens[0];
        const t2 = (andIdx >= 0 ? dateTokens.find(x => x.idx >= andIdx) : null) || dateTokens[1];
        const start = Math.min(t1.dayStart, t2.dayStart);
        const end = Math.max(t1.dayStart, t2.dayStart) + DAY_MS; // inclusive
        return { startMs: start, endMs: end, label: `between ${fmtDate(start)} and ${fmtDate(end - DAY_MS)}` };
      }

      // From DATE to DATE
      if (/\bfrom\b/.test(qLower) && dateTokens.length >= 2) {
        const fromIdx = qLower.indexOf("from");
        const toIdx = qLower.indexOf(" to ", fromIdx);
        const t1 = dateTokens.find(x => x.idx >= fromIdx) || dateTokens[0];
        const t2 = (toIdx >= 0 ? dateTokens.find(x => x.idx >= toIdx) : null) || dateTokens[1];
        const start = Math.min(t1.dayStart, t2.dayStart);
        const end = Math.max(t1.dayStart, t2.dayStart) + DAY_MS; // inclusive
        return { startMs: start, endMs: end, label: `${fmtDate(start)} to ${fmtDate(end - DAY_MS)}` };
      }

      // DATE - DATE (or DATE to DATE) range
      if (dateTokens.length >= 2) {
        for (let i = 0; i < dateTokens.length - 1; i++) {
          const a = dateTokens[i];
          const b = dateTokens[i + 1];
          const mid = qLower.slice(a.idx + a.len, b.idx).trim();

          const isDashRange = mid === "-" || mid === "‚Äì" || mid === "‚Äî";
          const isToRange = mid === "to" || mid === "thru" || mid === "through" || mid === "until";

          if (isDashRange || isToRange) {
            const start = Math.min(a.dayStart, b.dayStart);
            const end = Math.max(a.dayStart, b.dayStart) + DAY_MS; // inclusive
            return { startMs: start, endMs: end, label: `${fmtDate(start)} to ${fmtDate(end - DAY_MS)}` };
          }

          // Support compact "12/1-12/15" where mid might be "-" with no spaces (captured by substring trim)
          if (/^-$/.test(mid)) {
            const start = Math.min(a.dayStart, b.dayStart);
            const end = Math.max(a.dayStart, b.dayStart) + DAY_MS;
            return { startMs: start, endMs: end, label: `${fmtDate(start)} to ${fmtDate(end - DAY_MS)}` };
          }
        }
      }

      // Month range (December 2025) before named ranges, because "in December" should win over "last month"
      const monthRange = parseMonthRange(qLower, now);
      if (monthRange) return monthRange;

      // Named ranges (today, this week, last week, etc)
      const named = parseNamedRange(qLower, now, ctx);
      if (named) return named;

      // Numeric relatives (past 2 days, last 3 weeks)
      const rel = parseNumericRelative(qLower, now);
      if (rel) return rel;

      // If query mentions "week" but not specific, default to past 7 days (calendar anchored)
      if (/\bweek\b/.test(qLower)) {
        return { startMs: todayStart - 6 * DAY_MS, endMs: nowMs, label: "past 7 days" };
      }
      if (/\bmonth\b/.test(qLower)) {
        return { startMs: todayStart - 29 * DAY_MS, endMs: nowMs, label: "past 30 days" };
      }

      // If they asked about plural weekdays like "fridays" but gave no range, default to this year (useful + predictable)
      if (dayFilter && /\b(this year|last year|this month|last month|this week|last week|past|last|since|between|from|\d{1,2}\/\d{1,2}|20\d{2}-\d{1,2}-\d{1,2})\b/.test(qLower) === false) {
        const start = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0).getTime();
        return { startMs: start, endMs: nowMs, label: "this year" };
      }

      return null;
    }

    // --- Aggregation engine ---
    function aggregate(users, range, filters) {
      const startMs = range.startMs;
      const endMs = range.endMs;
      const dayFilter = filters?.dayFilter;

      const sums = {};
      const daySets = {};
      for (const u of users) {
        sums[u] = 0;
        daySets[u] = new Set();
      }

      let total = 0;
      const perDay = new Map(); // dayStart -> { Moe, Trish, total }
      const perDow = new Map(); // dow -> { Moe, Trish, total }

      const allowedDays = dayFilter?.days ? new Set(dayFilter.days) : null;

      for (const e of eventsCache) {
        if (!e) continue;
        if (e.ts < startMs || e.ts >= endMs) continue;
        if (!sums.hasOwnProperty(e.user)) continue;

        if (allowedDays && !allowedDays.has(e.dow)) continue;

        sums[e.user] += e.v;
        total += e.v;

        daySets[e.user].add(e.dayStart);

        // per day
        if (!perDay.has(e.dayStart)) perDay.set(e.dayStart, { Moe: 0, Trish: 0, total: 0 });
        const pd = perDay.get(e.dayStart);
        pd[e.user] = (pd[e.user] || 0) + e.v;
        pd.total += e.v;

        // per dow
        if (!perDow.has(e.dow)) perDow.set(e.dow, { Moe: 0, Trish: 0, total: 0 });
        const pw = perDow.get(e.dow);
        pw[e.user] = (pw[e.user] || 0) + e.v;
        pw.total += e.v;
      }

      return { sums, total, perDay, perDow, daySets };
    }

    function daysTouchedByRange(range, nowMs) {
      // Count calendar days overlapped by [startMs, endMs)
      const start = startOfDayLocal(range.startMs);
      const end = startOfDayLocal(Math.max(range.startMs, Math.min(range.endMs, nowMs) - 1)) + DAY_MS;
      return Math.max(1, Math.round((end - start) / DAY_MS));
    }

    // --- Natural Language Query handler ---
    const EXAMPLES_HTML = `
      Try questions like:<small>
      How many drinks did Moe have today?<br>
      How many drinks did Trish have in December 2025?<br>
      How many drinks both last week?<br>
      Who had more drinks last week?<br>
      Moe 12/1-12/15<br>
      Weekends last month<br>
      Fridays this year for Moe<br>
      Day by day last week
      </small>
    `;

    function handleQuery() {
      const raw = (el.queryInput?.value || "").trim();
      const now = new Date();
      const nowMs = now.getTime();

      if (!raw) {
        setQueryResult(EXAMPLES_HTML, false);
        return;
      }

      const qLower = normalizeQuery(raw);
      const intent = parseIntent(qLower);
      const userInfo = parseUsers(qLower, intent);
      const dayFilter = parseDayFilter(qLower);

      const preferCalendarLastWeek = !!(dayFilter && /\blast week\b/.test(qLower));
      const range = resolveTimeRange(raw, now, { preferCalendarLastWeek });

      if (!range) {
        setQueryResult(
          `Sorry - I could not find a time range in that question.<small>
          Try: today, yesterday, last week, calendar last week, past 7 days, last month, this year, or an explicit range like 12/1-12/15.
          </small>`,
          false
        );
        return;
      }

      // If they asked "this weekend" or "this friday" and it is in the future, avoid confusing 0s.
      if (range.startMs > nowMs) {
        setQueryResult(
          `That time range starts in the future (${fmtDate(range.startMs)}).<small>
          Try "last weekend" or "last Friday" for past results.
          </small>`,
          false
        );
        return;
      }

      const filters = { dayFilter };
      const agg = aggregate(userInfo.users, range, filters);

      const moeN = agg.sums["Moe"] || 0;
      const trishN = agg.sums["Trish"] || 0;

      const rangeText = fmtRange(range.startMs, range.endMs, nowMs);
      const filterText = dayFilter ? `, filter: ${dayFilter.label}` : "";
      const meta = `<small>Range used: ${rangeText}${filterText}</small>`;

      // --- Answer formatting by intent ---
      if (intent.type === "comparison") {
        // Who-only questions without explicit compare words should behave like "who drank" if applicable.
        const isWhoDrank = intent.whoSignals && !(/\bmore\b|\bmost\b|\bwinner\b|\bvs\b|\bversus\b|\bcompare\b/.test(qLower));

        if (isWhoDrank) {
          const who = [];
          if (moeN > 0) who.push(`Moe (${moeN})`);
          if (trishN > 0) who.push(`Trish (${trishN})`);
          if (who.length === 0) {
            setQueryResult(`No drinks logged in ${range.label}.${meta}`, true);
          } else if (who.length === 1) {
            setQueryResult(`${who[0]} logged drinks in ${range.label}.${meta}`, true);
          } else {
            setQueryResult(`${who.join(" and ")} logged drinks in ${range.label}.${meta}`, true);
          }
          return;
        }

        const leader =
          moeN === trishN ? null : (moeN > trishN ? "Moe" : "Trish");
        if (!leader) {
          setQueryResult(`Tie - Moe and Trish both had ${moeN} ${plural(moeN, "drink")} in ${range.label}.${meta}`, true);
          return;
        }
        const a = leader === "Moe" ? moeN : trishN;
        const b = leader === "Moe" ? trishN : moeN;

        // If question sounds yes/no: "did Trish drink more than Moe"
        const yesNo = /\bdid\b/.test(qLower) && (/\bmore than\b|\bless than\b/.test(qLower));
        if (yesNo) {
          const askedTrishMore = /\btrish\b.*\bmore than\b.*\bmoe\b|\bmore than\b.*\bmoe\b.*\btrish\b/.test(qLower) || /\btrish\b.*\bmore than\b/.test(qLower);
          const trishMore = trishN > moeN;
          const answer = askedTrishMore ? (trishMore ? "Yes" : "No") : (trishMore ? "No" : "Yes");
          setQueryResult(`${answer} - Moe: ${moeN}, Trish: ${trishN} in ${range.label}.${meta}`, true);
          return;
        }

        setQueryResult(
          `${leader} had more drinks than ${leader === "Moe" ? "Trish" : "Moe"} in ${range.label} (${a} vs ${b}).${meta}`,
          true
        );
        return;
      }

      if (intent.type === "difference") {
        const diff = Math.abs(moeN - trishN);
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          const n = agg.sums[u] || 0;
          setQueryResult(`${u} had ${n} ${plural(n, "drink")} in ${range.label}.${meta}`, true);
          return;
        }
        const leader = moeN === trishN ? null : (moeN > trishN ? "Moe" : "Trish");
        if (!leader) {
          setQueryResult(`Difference is 0 - Moe and Trish are tied at ${moeN} in ${range.label}.${meta}`, true);
          return;
        }
        setQueryResult(
          `${leader} led by ${diff} ${plural(diff, "drink")} in ${range.label} (Moe ${moeN} vs Trish ${trishN}).${meta}`,
          true
        );
        return;
      }

      if (intent.type === "average") {
        const daysCount = daysTouchedByRange(range, nowMs);
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          const n = agg.sums[u] || 0;
          const avg = n / daysCount;
          setQueryResult(
            `${u} averaged ${avg.toFixed(2)} ${plural(2, "drink")} per day in ${range.label} (${n} total over ${daysCount} ${plural(daysCount, "day")}).${meta}`,
            true
          );
          return;
        }
        const total = agg.total || 0;
        const avg = total / daysCount;
        setQueryResult(
          `Average ${avg.toFixed(2)} drinks per day in ${range.label} (${total} total over ${daysCount} ${plural(daysCount, "day")}).<br>Moe ${moeN}, Trish ${trishN}.${meta}`,
          true
        );
        return;
      }

      if (intent.type === "days_count") {
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          const d = agg.daySets[u]?.size || 0;
          setQueryResult(`${u} logged drinks on ${d} ${plural(d, "day")} in ${range.label}.${meta}`, true);
          return;
        }
        const dM = agg.daySets["Moe"]?.size || 0;
        const dT = agg.daySets["Trish"]?.size || 0;
        setQueryResult(`Days with drinks in ${range.label}: Moe ${dM}, Trish ${dT}.${meta}`, true);
        return;
      }

      if (intent.type === "peak_day") {
        // Find peak day by total (or by single user if specified)
        let bestDay = null;
        let bestVal = -Infinity;

        for (const [dayStart, rec] of agg.perDay.entries()) {
          const val = (userInfo.users.length === 1)
            ? (rec[userInfo.users[0]] || 0)
            : (rec.total || 0);
          if (val > bestVal) {
            bestVal = val;
            bestDay = dayStart;
          }
        }

        if (bestDay === null || bestVal <= 0) {
          setQueryResult(`No drinks logged in ${range.label}.${meta}`, true);
          return;
        }

        const when = fmtDate(bestDay);
        if (userInfo.users.length === 1) {
          const u = userInfo.users[0];
          setQueryResult(`${u}'s peak day in ${range.label} was ${when} with ${bestVal} ${plural(bestVal, "drink")}.${meta}`, true);
          return;
        }

        const rec = agg.perDay.get(bestDay);
        setQueryResult(
          `Peak day in ${range.label} was ${when} with ${bestVal} ${plural(bestVal, "drink")} total.<br>Moe ${rec.Moe || 0}, Trish ${rec.Trish || 0}.${meta}`,
          true
        );
        return;
      }

      if (intent.type === "breakdown") {
        const mode = intent.breakdownMode || "date";

        if (mode === "dow") {
          // Build Mon-Sun order for readability
          const order = [1,2,3,4,5,6,0];
          const lines = [];
          for (const dow of order) {
            const rec = agg.perDow.get(dow) || { Moe: 0, Trish: 0, total: 0 };
            if (userInfo.users.length === 1) {
              const u = userInfo.users[0];
              lines.push(`${DOW_SHORT[dow]}: ${rec[u] || 0}`);
            } else {
              lines.push(`${DOW_SHORT[dow]}: ${rec.total || 0}`);
            }
          }
          const header = (userInfo.users.length === 1)
            ? `${userInfo.users[0]} breakdown by day of week in ${range.label}:`
            : `Total breakdown by day of week in ${range.label}:`;

          setQueryResult(`${header}<br>${lines.join(" | ")}${meta}`, true);
          return;
        }

        // Date mode: day-by-day
        const days = Array.from(agg.perDay.entries()).sort((a, b) => a[0] - b[0]);
        if (days.length === 0) {
          setQueryResult(`No drinks logged in ${range.label}.${meta}`, true);
          return;
        }

        const maxLines = 10; // keep UI readable
        const shown = days.slice(-maxLines);
        const rows = shown.map(([dayStart, rec]) => {
          const dayLabel = `${monthNameFromIndex(new Date(dayStart).getMonth()).slice(0,3)} ${new Date(dayStart).getDate()}`;
          if (userInfo.users.length === 1) {
            const u = userInfo.users[0];
            return `${dayLabel}: ${rec[u] || 0}`;
          }
          return `${dayLabel}: Moe ${rec.Moe || 0}, Trish ${rec.Trish || 0}, total ${rec.total || 0}`;
        });

        const header = (days.length > maxLines)
          ? `Day-by-day (showing last ${maxLines} days in range) for ${range.label}:`
          : `Day-by-day for ${range.label}:`;

        setQueryResult(`${header}<br>${rows.join("<br>")}${meta}`, true);
        return;
      }

      // Default: count
      if (userInfo.mode === "who") {
        const who = [];
        if (moeN > 0) who.push(`Moe (${moeN})`);
        if (trishN > 0) who.push(`Trish (${trishN})`);
        if (who.length === 0) setQueryResult(`No drinks logged in ${range.label}.${meta}`, true);
        else setQueryResult(`${who.join(" and ")} logged drinks in ${range.label}.${meta}`, true);
        return;
      }

      if (userInfo.users.length === 1) {
        const u = userInfo.users[0];
        const n = agg.sums[u] || 0;
        setQueryResult(`${u} had ${n} ${plural(n, "drink")} in ${range.label}.${meta}`, true);
        return;
      }

      const total = agg.total || 0;
      setQueryResult(
        `Moe had ${moeN} ${plural(moeN, "drink")}, Trish had ${trishN} ${plural(trishN, "drink")}. Total ${total} ${plural(total, "drink")} in ${range.label}.${meta}`,
        true
      );
    }

    if (el.querySubmit) el.querySubmit.addEventListener("click", handleQuery);
    if (el.queryInput) {
      el.queryInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handleQuery();
      });
    }

    // --- View / Nav (function declarations are hoisted) ---
    function switchTab(tab) {
      el.tabTracker.classList.toggle("active", tab === "tracker");
      el.tabAnalytics.classList.toggle("active", tab === "analytics");

      el.viewTracker.classList.toggle("hidden", tab !== "tracker");
      el.viewAnalytics.classList.toggle("hidden", tab !== "analytics");

      el.header.innerText = tab === "tracker" ? "Drink Tracker" : "History";
    }
    window.switchTab = switchTab; // keep inline onclick working

    function startApp() {
      el.viewLogin.classList.add("hidden");
      el.nav.classList.remove("hidden");
      switchTab("tracker");

      // Helpful default prompt
      if (el.queryResults && el.queryResults.innerHTML.trim() === "") {
        setQueryResult(EXAMPLES_HTML, false);
      }
    }

    // --- Auth ---
    function login() {
      if (el.pass.value === "Moetrin") {
        localStorage.setItem("auth_token", "Moetrin");
        startApp();
      } else {
        alert("Wrong Password");
        el.pass.value = "";
      }
    }

    el.btnLogin.addEventListener("click", login);
    el.pass.addEventListener("keydown", (e) => {
      if (e.key === "Enter") login();
    });

    // --- Drinks ---
    function addDrink(user, amount) {
      const card = user === "Moe" ? el.cardMoe : el.cardTrish;

      if (amount > 0) {
        push(historyRef, { user, timestamp: Date.now(), value: 1 });

        const pop = document.createElement("div");
        pop.className = "kanpai-pop";
        pop.innerText = "üçª Kanpai!";
        card.appendChild(pop);
        setTimeout(() => pop.remove(), 800);
        return;
      }

      let lastId = null;
      let lastTime = 0;

      for (const [id, data] of Object.entries(allHistory || {})) {
        if (data && data.user === user && typeof data.timestamp === "number" && data.timestamp > lastTime) {
          lastTime = data.timestamp;
          lastId = id;
        }
      }

      if (lastId) {
        remove(ref(db, "history/" + lastId));
        card.style.transform = "translateX(5px)";
        setTimeout(() => (card.style.transform = "translateX(-5px)"), 50);
        setTimeout(() => (card.style.transform = "none"), 100);
      }
    }
    window.addDrink = addDrink; // keep inline onclick working

    // --- Stats (tracker + summary table) ---
    function updateText(id, val) {
      const node = document.getElementById(id);
      if (node) node.innerText = String(val);
    }

    function calculate() {
      const now = new Date();
      const nowMs = now.getTime();

      const todayStart = startOfDayLocal(now);
      const start7 = todayStart - (7 - 1) * DAY_MS;   // last 7 calendar days including today
      const start30 = todayStart - (30 - 1) * DAY_MS; // last 30 calendar days including today

      const stats = {
        moe: { day: 0, week: 0, month: 0, all: 0 },
        trish: { day: 0, week: 0, month: 0, all: 0 }
      };

      for (const e of eventsCache) {
        const u = e.user?.toLowerCase();
        if (!u || !stats[u]) continue;

        stats[u].all += e.v;
        if (e.ts >= start30) stats[u].month += e.v;
        if (e.ts >= start7) stats[u].week += e.v;
        if (e.ts >= todayStart) stats[u].day += e.v;
      }

      el.cMoe.innerText = stats.moe.day;
      el.cTrish.innerText = stats.trish.day;

      updateText("stat-day-moe", stats.moe.day);
      updateText("stat-day-trish", stats.trish.day);
      updateText("stat-week-moe", stats.moe.week);
      updateText("stat-week-trish", stats.trish.week);
      updateText("stat-month-moe", stats.moe.month);
      updateText("stat-month-trish", stats.trish.month);
      updateText("stat-all-moe", stats.moe.all);
      updateText("stat-all-trish", stats.trish.all);

      el.cardMoe.classList.remove("active-user");
      el.cardTrish.classList.remove("active-user");

      if (stats.moe.day > 0 || stats.trish.day > 0) {
        if (stats.moe.day > stats.trish.day) el.cardMoe.classList.add("active-user");
        else if (stats.trish.day > stats.moe.day) el.cardTrish.classList.add("active-user");
      }
    }

    // --- Realtime listener ---
    onValue(historyRef, (snapshot) => {
      allHistory = snapshot.val() || {};
      rebuildEventsCache();
      calculate();
    });

    // --- Auto-start ---
    if (localStorage.getItem("auth_token") === "Moetrin") {
      startApp();
    }
  </script>
</body>
</html>
